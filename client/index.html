<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Live Depth Point Cloud + Rain Collisions + WebXR</title>
  <link rel="icon" href="data:,">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

  <style>
    html,body { margin:0; height:100%; overflow:hidden; background:#000; }
    #overlay { position:fixed; top:12px; left:120px; color:#0f0; font:12px/1.4 monospace; background:rgba(0,0,0,.4); padding:8px 10px; border-radius:8px; z-index:15; }
    #overlay.error { color:#ff5555; }

    /* Existing camera bars */
    #bars { position:fixed; bottom:12px; left:12px; display:flex; gap:8px; z-index:10; }
    .bar { background:rgba(0,0,0,.65); color:#0f0; font:12px/1.4 monospace; padding:8px 10px; border-radius:8px; display:flex; gap:6px; align-items:center; }
    .bar label { opacity:.85; }
    .bar select, .bar button {
      background:#111; color:#0f0; border:1px dotted; #0f0; border-radius:6px; padding:3px 6px; font:12px/1.2 monospace;
    }
    .bar select, .bar button:hover {
      background:#111; color:#0f0; border:1px solid; #0f0; border-radius:6px; padding:3px 6px; font:12px/1.2 monospace;
    }


    .muted { opacity:.45; pointer-events:none; }

    /* NEW: on-screen action buttons that mirror keyboard shortcuts */
    #actions { position:fixed; bottom:12px; right:12px; display:flex; flex-wrap:wrap; gap:8px; z-index:12; }
    #actions .bar { gap:6px; }

    /* Larger touch targets on mobile */
    @media (hover:none) and (pointer:coarse) {
      .bar select, .bar button { padding:8px 10px; font-size:14px; }
    }

    /* Portrait/mobile: stack and lift camera bars so they don't collide with XR button */
    @media (max-aspect-ratio: 1/1) {
      #bars { flex-direction:column; bottom:88px; left:12px; right:auto; }
      #overlay { left:12px; }
      #actions { top:auto; bottom:12px; right:12px; }
    }

    #dropHint {
      position: fixed; inset: 0;
      display: none; place-items: center;
      background: rgba(0,0,0,.35);
      color: #0f0; font: 16px/1.4 monospace;
      z-index: 9999;
    }
    #dropHint.show { display: grid; }


  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/",
        "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.20/dist/lil-gui.esm.min.js"
      }
    }
  </script>


<!--   <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.180.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.180.0/examples/jsm/",
        "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.18/dist/lil-gui.esm.min.js"
      }
    }
  </script> -->


</head>
<body>
  <div id="overlay">connecting‚Ä¶</div>
  <!-- Model loader UI -->
  <input id="fileInput" type="file" accept=".glb,.gltf" multiple style="display:none">

  <input id="presetFile" type="file" accept=".json" style="display:none">

  <div id="dropHint" style="display:none;">Drop .glb / .gltf files to load</div>


  <!-- NEW: Action buttons -->
  <div id="actions">
    <div class="bar">
      <button id="btnPause" title="[P] Pause/Resume">‚è∏</button>
      <button id="btnSave" title="[S] Save">Save</button>
      <button id="btnFull" title="[F] FScreen">‚õ∂</button>
      <button id="btnBuild" title="[B] Build">‚ñ£</button>
      <button id="btnDissolve" title="[D] Dissolve">‚úπ</button>
      <button id="btnReset" title="[R] Reset">‚Ü∫</button>
      <button id="btnFilter" title="[T] Cycle">üé®</button>
      <button data-mode="1" class="btnMode" title="[1] Stick">1</button>
      <button data-mode="2" class="btnMode" title="[2] Fly-up">2</button>
      <button data-mode="3" class="btnMode" title="[3] Radial">3</button>
      <button data-mode="4" class="btnMode" title="[4] Random">4</button>
      <button id="btnLoad" title="Load GLB/GLTF">Load</button>
    </div>
  </div>

  <div id="bars">
    <div class="bar" id="browserBar">
      <label for="camSelect">Browser cam:</label>
      <select id="camSelect"><option value="">(loading‚Ä¶)</option></select>
      <button id="refreshBtn" title="Rescan cameras">‚Üª</button>
    </div>
    <div class="bar" id="serverBar">
      <label for="srvSelect">Server cam:</label>
      <select id="srvSelect"><option value="">(WS not connected)</option></select>
      <button id="srvRefresh" title="Ask server">‚Üª</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { GLTFExporter } from "three/addons/exporters/GLTFExporter.js";

    // --- ADD WITH OTHER IMPORTS (near OrbitControls/Exporter) ---
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
    
    import { TransformControls } from "three/addons/controls/TransformControls.js";


    import { GUI } from "lil-gui";
    import { XRButton } from "three/addons/webxr/XRButton.js";
    import { ARButton } from "three/addons/webxr/ARButton.js";
    import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";
    import { XRHandModelFactory }     from "three/addons/webxr/XRHandModelFactory.js"; 





    // ---------- UI refs ----------
    const overlay   = document.getElementById("overlay");
    const browserBar= document.getElementById("browserBar");
    const serverBar = document.getElementById("serverBar");
    const camSelect = document.getElementById("camSelect");
    const refreshBtn= document.getElementById("refreshBtn");
    const srvSelect = document.getElementById("srvSelect");
    const srvRefresh= document.getElementById("srvRefresh");

    // NEW: action buttons
    const btnPause = document.getElementById('btnPause');
    const btnSave  = document.getElementById('btnSave');
    const btnFull  = document.getElementById('btnFull');
    const btnBuild = document.getElementById('btnBuild');
    const btnDissolve = document.getElementById('btnDissolve');
    const btnReset = document.getElementById('btnReset');
    const btnFilter= document.getElementById('btnFilter');
    const btnModeEls = Array.from(document.querySelectorAll('.btnMode'));

    let statusText = "connecting‚Ä¶";
    let paused = false;
    let lastHeader = null;


    let _dbPromise = null;
    // --- PERSISTENCE: IndexedDB (presets) + localStorage (autosave) ---
    const DB_NAME = "LiveDepthViewerDB";
    const DB_VERSION = 1;
    const STORE = "presets";        


    // ---------- Scene ----------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 100);
    camera.position.set(0, 0, 2);



    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha:true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    console.log('THREE revision:', THREE.REVISION);
    console.log('TransformControls instanceof Object3D?', (new TransformControls(camera, renderer.domElement)) instanceof THREE.Object3D);

    // Orbit controls (disabled during XR sessions)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // A group that holds *everything* we want to position/scale in XR
    const cloudGroup = new THREE.Group();
    scene.add(cloudGroup);

    // Floor for VR (hidden in AR)
    const floorSize = 8, floorDiv = 32;
    const floorGrid = new THREE.GridHelper(floorSize, floorDiv, 0x224422, 0x112211);
    floorGrid.position.y = -1.6;
    floorGrid.visible = true;
    scene.add(floorGrid);

    // Subtle lighting
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(1,1,1);
    scene.add(dirLight, new THREE.AmbientLight(0xffffff, 0.2));

    // ---------- Transitions ----------
    const TRANSITION = { NORMAL:0, BUILD:1, DISSOLVE:2 };
    let transitionMode = TRANSITION.NORMAL;
    const BUILD_MS = 1200, DISSOLVE_MS = 1200, DISSOLVE_SPEED = 1.8;
    let dissolveVel = null, dissolveElapsed = 0;

    // ---------- Params / GUI ----------
    const FILTERS = { None:0, Monochrome:1, Invert:2, "Invert+Mono":3, "Tint Red":4, "Red‚ÜíYellow":5 };
    const SOURCE  = { PythonWS: "Python (WS)", BrowserCam: "Browser Webcam" };

    const params = {

      source: SOURCE.PythonWS,
      filter: FILTERS.None, hue: 0, tintAmount: 0.55, brightness: 1.0, contrast: 1.0,
      clamp: true, bwEnabled: false, bwThreshold: 0.5,
      pointSize: 0.010, pointShape: "square", shapeFeather: 1.25, crossThickness: 0.22,
      rainSpeed: 1.0,
      camWidth: 320, camStride: 2, camDepthScale: 1.6, camDepthOffset: 0.4, camFlipX: false, camFlipY: false,

      // XR placement tuning
      xrScale: 0.22,           // smaller in XR
      xrDistance: 1.0,         // ~1m in front
      xrYOffset: -0.4,         // a bit below head level
      xrPointPixelSize: 0.02,   // ~2mm screen-space in AR

      rainCount: 1200,       // total drops
      rainSize: 0.002,       // PointsMaterial.size

      tweenAuto: true,        // auto: follow incoming frame cadence
      tweenMs: 120,           // manual tween duration (ms) when tweenAuto = false
      tweenMinMs: 40,         // clamps for auto
      tweenMaxMs: 300,
      tweenAlpha: 0.25,       // EMA factor for auto (0..1) higher = faster reaction
      tweenEasing: "linear",  // "linear","easeIn","easeOut","easeInOut","smoothstep","smootherstep"

    };


      // Depth fade (view-space Z)
    Object.assign(params, {
      fadeEnabled: true,
        fadeStart: 0.8,   // meters from camera where fade begins
        fadeEnd:   2.0,   // meters where points are fully gone
        fadeDither: true  // stochastic screen-door to avoid sorting artifacts
      });


    Object.assign(params, {
      serverEmaAlpha: 0.2,
      serverClampNear: 0.2,
      serverClampFar: 1.0
    });



    const gui = new GUI();


    const gColor = gui.addFolder("Color");
    gColor.add(params, "filter", FILTERS).name("Mode").onChange(reapplyFilter);
    gColor.add(params, "hue", 0, 360, 1).name("Hue Rotation").onChange(reapplyFilter);
    const tintCtrl = gColor.add(params, "tintAmount", 0, 1, 0.01).name("Tint Amount").onChange(reapplyFilter);
    gColor.add(params, "brightness", 0.25, 2.0, 0.01).name("Brightness").onChange(reapplyFilter);
    gColor.add(params, "contrast", 0.2, 3.0, 0.01).name("Contrast").onChange(reapplyFilter);
    gColor.add(params, "clamp").name("Clamp 0..1").onChange(reapplyFilter);
    gColor.add(params, "bwEnabled").name("B&W Threshold").onChange(reapplyFilter);
    gColor.add(params, "bwThreshold", 0, 1, 0.01).name("Threshold").onChange(reapplyFilter);
    gColor.open();
    gui.onChange(() => { params.filter === FILTERS["Tint Red"] ? tintCtrl.enable() : tintCtrl.disable(); });

    const gPoints = gui.addFolder("Points");
    gPoints.add(params, "pointSize", 0.002, 0.05, 0.001).name("Size").onChange(()=>{
      cloudMaterial.size = params.pointSize; if (paused) renderer.render(scene, camera);
    });
    gPoints.add(params, "pointShape", ["square","circle","cross"]).name("Shape").onChange(setPointShape);
    gPoints.add(params, "shapeFeather", 0.0, 4.0, 0.01).name("Edge Softness").onChange(setPointShape);
    gPoints.add(params, "crossThickness", 0.05, 0.5, 0.005).name("Cross Thickness").onChange(setPointShape);
    gPoints.open();


    const gFade = gui.addFolder("Depth Fade");
    gFade.add(params, "fadeEnabled").name("Enabled").onChange(()=>updateDepthFadeAll());
    gFade.add(params, "fadeStart", 0.0, 5.0, 0.01).name("Start (m)").onChange(()=>updateDepthFadeAll());
    gFade.add(params, "fadeEnd",   0.0, 5.0, 0.01).name("End (m)").onChange(()=>updateDepthFadeAll());
    gFade.add(params, "fadeDither").name("Dither").onChange(()=>updateDepthFadeAll());


    const gSource = gui.addFolder("Source");
    gSource.add(params, "source", [SOURCE.PythonWS, SOURCE.BrowserCam]).name("Input").onChange(onSourceChanged);
    const gWebcam = gSource.addFolder("Webcam (synthetic depth)");
    gWebcam.add(params, "camWidth", 80, 640, 10).name("Process Width");
    gWebcam.add(params, "camStride", 1, 4, 1).name("Grid Stride");
    gWebcam.add(params, "camDepthScale", 0.1, 4.0, 0.05).name("Depth Scale");
    gWebcam.add(params, "camDepthOffset", 0.0, 2.0, 0.05).name("Depth Offset");
    gWebcam.add(params, "camFlipX").name("Flip X");
    gWebcam.add(params, "camFlipY").name("Flip Y");
    gSource.open();


    let _pushTimer = 0;
    function pushServerParams(){
      if (!wsConnected || !ws) return;
      clearTimeout(_pushTimer);
      _pushTimer = setTimeout(()=>{
        try {
          const near = Math.min(params.serverClampNear, params.serverClampFar - 1e-3);
          const far  = Math.max(params.serverClampFar,  near + 1e-3);
          ws.send(JSON.stringify({
            cmd: "set_params",
            ema_alpha: params.serverEmaAlpha,
            clamp_near: near,
            clamp_far: far
          }));
        } catch(e){}
      }, 120);
    }

    const gServer = gui.addFolder("Server Depth (live)");
    gServer.add(params, "serverEmaAlpha", 0, 1, 0.01).name("EMA Œ±").onChange(pushServerParams);
    gServer.add(params, "serverClampNear", 0.0, 3.0, 0.01).name("Clamp Near").onChange(pushServerParams);
    gServer.add(params, "serverClampFar",  0.01, 5.0, 0.01).name("Clamp Far").onChange(pushServerParams);


    // --- Rain GUI ---
    const gRain = gui.addFolder("Rain");

    // Speed (scales existing velocities so it feels immediate)
    gRain.add(params, "rainSpeed", 0.1, 4.0, 0.01).name("Speed")
    .onChange(v => {
      if (!rainVX) return;
      const prev = gRain.__prevSpeed || 1;
      const scale = v / prev;
      for (let i=0;i<rainVX.length;i++){
        rainVX[i] *= scale; rainVY[i] *= scale; rainVZ[i] *= scale;
      }
      gRain.__prevSpeed = v;
    });

// Count (rebuild buffers)
    gRain.add(params, "rainCount", 0, 10000, 100).name("Count")
    .onChange(v => rebuildRain(v|0));

// Size (update material)
    gRain.add(params, "rainSize", 0.0005, 0.02, 0.0005).name("Drop Size")
    .onChange(v => { if (rainMat){ rainMat.size = v; rainMat.needsUpdate = true; } });

    gRain.open();


    // --- Smooth GUI ---

    function ease01(t, mode){
      t = Math.max(0, Math.min(1, t));
      switch (mode){
      case "easeIn":        return t*t*t;
      case "easeOut":       { const u=1-t; return 1-u*u*u; }
      case "easeInOut":     { if (t<0.5) return 4*t*t*t; const u=2*t-2; return 0.5*u*u*u+1; }
      case "smoothstep":    return t*t*(3-2*t);
      case "smootherstep":  return t*t*t*(t*(6*t-15)+10);
    default:              return t; // linear
    }
  }




// --- HANDS & HAND STEAM (unit-safe) -----------------------------------------
// Forward declarations so early helpers (like syncComputedHandSizes) can touch these safely
  let hand0Points = null;
  let hand1Points = null;
let handSteamMat = null;   // used by applyHandSteamSize() and rebuildHandSteam()

let hsSize=null, hsAge=null, hsSeed=null, hsLifeTotal=null;


// helpers (local to this block)
function isARSession(){
  const s = renderer.xr.getSession();
  return !!s && (s.environmentBlendMode !== 'opaque');
}
function applyHandPointSizeTo(mat){
  const ar = isARSession();
  mat.sizeAttenuation = !ar; // AR: pixels, VR/Desktop: meters
  mat.size = ar ? params.handPointSizePx : params.handPointSizeWorld;
  mat.needsUpdate = true;
}
function applyHandSteamSize(){
  if (!handSteamMat) return;
  const ar = isARSession();
  handSteamMat.sizeAttenuation = !ar; // AR: pixels, VR/Desktop: meters
  handSteamMat.size = ar ? params.handSteamSizePx : params.handSteamSizeWorld;
  handSteamMat.needsUpdate = true;
}
function syncComputedHandSizes(){
  // keep legacy fields updated so existing code that reads params.handPointSize / handSteamSize keeps working
  const ar = isARSession();
  params.handPointSize = ar ? params.handPointSizePx : params.handPointSizeWorld;
  params.handSteamSize = ar ? params.handSteamSizePx : params.handSteamSizeWorld;

  // push to live materials if they exist
  if (hand0Points?.material) applyHandPointSizeTo(hand0Points.material);
  if (hand1Points?.material) applyHandPointSizeTo(hand1Points.material);
  applyHandSteamSize();
}

// -------------------- HANDS (params + GUI) --------------------
Object.assign(params, {
  handClusterCount: 12,
  handClusterRadius: 0.012,

  // NEW: dual-unit sizing + legacy mirror
  handPointSizePx: 4.0,       // AR: pixels
  handPointSizeWorld: 0.02,   // VR/Desktop: meters
  handPointSize: 0.02,        // legacy (auto-updated via syncComputedHandSizes)

  handBrightness: 1.2
});

const gHands = gui.addFolder("Hands");
gHands.add(params, "handClusterCount", 1, 60, 1).name("Density (pts/joint)")
.onChange(()=> rebuildHandPoints());
gHands.add(params, "handClusterRadius", 0.002, 0.04, 0.001).name("Cluster Radius (m)");

// NEW: two sliders, no more direct use of legacy size in GUI
gHands.add(params, "handPointSizePx", 0.5, 20, 0.1).name("Point Size (px)")
.onChange(()=> syncComputedHandSizes());
gHands.add(params, "handPointSizeWorld", 0.001, 0.1, 0.001).name("Point Size (m)")
.onChange(()=> syncComputedHandSizes());

gHands.add(params, "handBrightness", 0.5, 3.0, 0.05).name("Brightness").onChange(()=>{
  [hand0Points, hand1Points].forEach(pts=>{
    const col = pts?.geometry?.getAttribute('color'); if (!col) return;
    const a = col.array; for (let i=0;i<a.length;i++) a[i] = Math.min(1, a[i]); // re-brighten in update loop
    col.needsUpdate = true;
  });
});

// -------------------- HAND STEAM (params + GUI) --------------------
Object.assign(params, {
  handSteamEnabled: true,
  handSteamCount: 11000,
  handSteamSpeed: 1.0,

  // NEW: dual-unit sizing + legacy mirror
  handSteamSizePx: 3.0,        // AR: pixels
  handSteamSizeWorld: 0.006,   // VR/Desktop: meters
  handSteamSize: 0.006,        // legacy (auto-updated via syncComputedHandSizes)

  handSteamBirthsPerFrame: 400,
  handSteamUpVel: 0.6,
  handSteamSpread: 0.005,
  handSteamDrag: 0.6,
  handSteamColor: [0.85, 0.9, 1.0],

  handSteamAttractEnabled: true,
  handSteamAttractStrength: 5.5,
  handSteamAttractMax: 0.55,

  handSteamShape: "soft",          // "soft" | "circle" | "triangle" | "spark"
  handSteamSizeMin: 0.6,           // multiplies material size
  handSteamSizeMax: 1.8,
  handSteamAlphaMode: "smootherstep", // "linear" | "smoothstep" | "smootherstep"
  handSteamDepthNoise: 0.018,      // meters of z-wobble (adds volume)
  handSteamTurbulenceHz: 1.6,       // animation speed for wobble

  handSteamAttractTurbAmp: 0.35,  // 0..1  ‚Üí ¬±35% strength wobble
  handSteamAttractTurbHz:  0.8,   // Hz    ‚Üí how fast it wiggles
  handSteamAttractRangeJitter: 0.25 // 0..1 ‚Üí ¬±25% range wobble


});


let steamTime = 0;
const gSteam = gui.addFolder("Hand Steam");

// BEFORE: it scaled hsVel ... remove that scaling
gSteam.add(params, "handSteamSpeed", 0.05, 2.0, 0.01).name("Speed")
.onChange(v => {
    gSteam.__prevSteamSpeed = v;  // keep for GUI state only
  });



gSteam.add(params, "handSteamEnabled").name("Enabled").onChange(v=>{
  if (handSteamPoints) handSteamPoints.visible = !!v;
});
gSteam.add(params, "handSteamCount", 0, 20000, 100).name("Count")
.onChange(v=> rebuildHandSteam(v|0));

// NEW: two sliders, legacy value kept in sync
gSteam.add(params, "handSteamSizePx", 0.5, 20, 0.1).name("Point Size (px)")
.onChange(()=> syncComputedHandSizes());
gSteam.add(params, "handSteamSizeWorld", 0.001, 0.05, 0.001).name("Point Size (m)")
.onChange(()=> syncComputedHandSizes());

gSteam.add(params, "handSteamBirthsPerFrame", 0, 5000, 10).name("Births / frame");
gSteam.add(params, "handSteamUpVel", 0.0, 2.0, 0.01).name("Upward m/s");
gSteam.add(params, "handSteamSpread", 0.001, 0.06, 0.001).name("Spawn Spread (m)");
gSteam.add(params, "handSteamDrag", 0.0, 4.0, 0.01).name("Drag (1/s)");

gSteam.add(params, "handSteamShape", ["soft","circle","triangle","spark"]).name("Billboard");
gSteam.add(params, "handSteamSizeMin", 0.1, 3.0, 0.05).name("Size Min");
gSteam.add(params, "handSteamSizeMax", 0.1, 3.0, 0.05).name("Size Max");
gSteam.add(params, "handSteamAlphaMode", ["linear","smoothstep","smootherstep"]).name("Alpha Curve");
gSteam.add(params, "handSteamDepthNoise", 0.0, 0.06, 0.001).name("Depth Noise (m)");
gSteam.add(params, "handSteamTurbulenceHz", 0.1, 6.0, 0.1).name("Turbulence (Hz)");


const gSteamAttr = gSteam.addFolder("Attractor");
gSteamAttr.add(params, "handSteamAttractEnabled").name("Enabled")
.onChange(v=>{ if (attractorSphere) attractorSphere.visible = !!v; });
gSteamAttr.add(params, "handSteamAttractStrength", 0.0, 12.0, 0.1).name("Strength");
gSteamAttr.add(params, "handSteamAttractMax", 0.05, 2.5, 0.01).name("Max Distance (m)");

gSteamAttr.add(params, "handSteamAttractTurbAmp", 0.0, 1.0, 0.01).name("Strength Turb (¬±)");
gSteamAttr.add(params, "handSteamAttractTurbHz",  0.05, 6.0, 0.05).name("Turbulence Hz");
gSteamAttr.add(params, "handSteamAttractRangeJitter", 0.0, 1.0, 0.01).name("Range Jitter (¬±)");



// initialize legacy mirrors & materials once
syncComputedHandSizes();




const gSmooth = gui.addFolder("Smoothing");
gSmooth.add(params, "tweenAuto").name("Auto smoothing");
gSmooth.add(params, "tweenMs", 10, 800, 1).name("Manual œÑ (ms)")
.onChange(v => { if (!params.tweenAuto) tauMs = (v|0); });
gSmooth.add(params, "tweenMinMs", 10, 800, 1).name("Auto min œÑ");
gSmooth.add(params, "tweenMaxMs", 30, 1000, 1).name("Auto max œÑ");
gSmooth.add(params, "tweenAlpha", 0.05, 0.8, 0.01).name("Auto EMA Œ±");
// We ignore tweenEasing for live smoothing; keep it for BUILD transitions if you want:
gSmooth.add(params, "tweenEasing", ["linear","easeIn","easeOut","easeInOut","smoothstep","smootherstep"])
.name("Build easing");
gSmooth.open();





const gXR = gui.addFolder("XR Placement");
gXR.add(params, "xrScale", 0.05, 1.0, 0.01).name("Scale");
gXR.add(params, "xrDistance", 0.4, 3.0, 0.05).name("Distance");
gXR.add(params, "xrYOffset", -1.0, 1.0, 0.02).name("Y Offset");
gXR.add(params, "xrPointPixelSize", 0.005, 0.05, 0.001).name("AR Point px");



// --- PRESETS GUI -------------------------------------------------------------
const presetFile = document.getElementById("presetFile");

const presetState = {
  selected: "",
  nameToSave: "",
};

const gPresets = gui.addFolder("Presets");

// We'll recreate this controller whenever the list changes
let presetCtrl = null;

function buildPresetController(names) {
  // Destroy old controller safely (lil-gui API)
  if (presetCtrl) {
    presetCtrl.destroy();
    presetCtrl = null;
  }

  // Map array -> options object { "name":"name", ... } for a select control
  const opts = names.reduce((acc, n) => (acc[n] = n, acc), {});
  presetCtrl = gPresets.add(presetState, "selected", opts).name("Select");

  // Auto-load on change
  presetCtrl.onChange(async (name) => {
    if (!name) return;
    const st = await idbGetPreset(name);
    if (st) {
      applyState(st);
      scheduleAutosave();
    }
  });
}

gPresets.add(presetState, "nameToSave").name("Name");

const refreshPresetList = async () => {
  const list  = await idbListPresets();
  const names = list.map(p => p.name).sort((a, b) => a.localeCompare(b));

  // keep selection if possible
  if (!names.includes(presetState.selected)) {
    presetState.selected = names[0] || "";
  }

  // Rebuild the controller with the new options (avoids NotFoundError)
  buildPresetController(names);
};

gPresets.add({ Save: async () => {
  const name = (presetState.nameToSave || presetState.selected || "").trim();
  if (!name) { alert("Enter a preset name."); return; }
  await idbPutPreset(name, currentState());
  presetState.selected   = name;
  presetState.nameToSave = "";
  await refreshPresetList();
}}, "Save");

gPresets.add({ Load: async () => {
  if (!presetState.selected) { alert("Choose a preset."); return; }
  const st = await idbGetPreset(presetState.selected);
  if (!st) { alert("Preset missing."); return; }
  applyState(st);
  scheduleAutosave();
}}, "Load");

gPresets.add({ Delete: async () => {
  if (!presetState.selected) { alert("Choose a preset."); return; }
  if (!confirm(`Delete preset "${presetState.selected}"?`)) return;
  await idbDeletePreset(presetState.selected);
  presetState.selected = "";
  await refreshPresetList();
}}, "Delete");

gPresets.add({ Export: () => {
  const name = presetState.selected || presetState.nameToSave || "preset";
  const blob = new Blob([ JSON.stringify(currentState(), null, 2) ], { type:"application/json" });
  saveBlob(blob, `${name.replace(/[^\w.-]+/g,'_')}.json`);
}}, "Export");

gPresets.add({ Import: () => presetFile?.click() }, "Import");

// Handle Import file select (unchanged)
presetFile?.addEventListener("change", async (e) => {
  const f = e.target.files?.[0];
  if (!f) return;
  try {
    const txt = await f.text();
    const st  = JSON.parse(txt);
    let name  = prompt("Preset name to save as:", (st?.presetName || f.name.replace(/\.json$/i,'') || "Imported"));
    if (!name) return;
    await idbPutPreset(name, st);
    presetState.selected = name;
    await refreshPresetList();
    applyState(st);
    scheduleAutosave();
  } catch (err) {
    alert("Import failed: " + (err?.message || err));
  } finally {
    e.target.value = "";
  }
});

// initial list
refreshPresetList();
gPresets.open();





// --- STATE: capture/apply ----------------------------------------------------
function clone(obj){ return JSON.parse(JSON.stringify(obj)); }

function currentState(){
  // What we persist:
  // - camera & orbit target
  // - all tweakable params (including server* + rain + smoothing + XR placement + color/points/fade)
  // - selection of source, current browser cam id, server cam index (UI reads it)
  // - external model transforms (by id & name) but NOT heavy geometry
  const models = externalGroups.map(g => ({
    id: g.id, name: g.name, visible: g.visible, density: g.density,
    t: { x:g.group.position.x, y:g.group.position.y, z:g.group.position.z },
    r: { x:g.group.rotation.x, y:g.group.rotation.y, z:g.group.rotation.z },
    s: g.group.scale.x
  }));
  return {
    version: 1,
    camera: {
      position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
      target:   { x: controls.target.x, y: controls.target.y, z: controls.target.z },
      fov: camera.fov,
    },
    ui: {
      source: params.source,
      browserCamId: currentCamId || "",
      serverSelectedIndex: srvSelect?.value ?? null,
    },
    params: clone(params),
    models
  };
}




function applyState(state, { silent = false } = {}) {
  try {
    if (!state) return;

    // --- Camera + orbit target ---
    if (state.camera) {
      const p = state.camera.position || {};
      const t = state.camera.target   || {};
      if (Number.isFinite(p.x)) camera.position.set(p.x, p.y, p.z);
      if (Number.isFinite(t.x)) controls.target.set(t.x, t.y, t.z);
      if (Number.isFinite(state.camera.fov)) {
        camera.fov = state.camera.fov;
        camera.updateProjectionMatrix();
      }
      controls.update();
    }

    // --- Params (only keys that exist) ---
    if (state.params) {
      Object.keys(state.params).forEach(k => {
        if (k in params) params[k] = state.params[k];
      });

      // Refresh materials / uniforms / GUI displays
      setPointShape();
      updateDepthFadeAll();
      try { gui.controllersRecursive?.forEach?.(c => c.updateDisplay?.()); } catch {}
      try { gServer?.controllers?.forEach?.(c => c.updateDisplay?.()); } catch {}

      // Main cloud size from preset
      cloudMaterial.size = params.pointSize;
      cloudMaterial.needsUpdate = true;

      // External point clouds keep in sync with current params
      updateExternalPointMaterials();

      // ---------- HANDS + HAND STEAM ----------
      // Keep unit-mirrors (px vs m) in sync with current XR mode, then push sizes.
      syncComputedHandSizes();

      if (hand0Points?.material) applyHandPointSizeTo(hand0Points.material);
      if (hand1Points?.material) applyHandPointSizeTo(hand1Points.material);

      // Rebuild steam count if needed; otherwise just reapply size/visibility
      const wantSteamCount = (params.handSteamCount | 0);
      if (typeof wantSteamCount === "number" && hsLife && hsLife.length !== wantSteamCount) {
        rebuildHandSteam(wantSteamCount);
      }
      // Ensure material sizing and visibility match the preset
      applyHandSteamSize();
      if (handSteamPoints) handSteamPoints.visible = !!params.handSteamEnabled;

      // Attractor visibility follows the toggle
      if (typeof attractorSphere !== "undefined" && attractorSphere) {
        attractorSphere.visible = !!params.handSteamAttractEnabled;
      }

      // Hand Steam speed ‚Üí scale existing velocities immediately (like rain)
      //   (() => {
      //     if (!hsVel || typeof params.handSteamSpeed !== "number") return;
      //     const prev = (gSteam && gSteam.__prevSteamSpeed) ? gSteam.__prevSteamSpeed : 1;
      //     if (prev > 0 && prev !== params.handSteamSpeed) {
      //       const s = params.handSteamSpeed / prev;
      //       for (let i = 0; i < hsVel.length; i++) hsVel[i] *= s; // scales all xyz comps
      //     }
      //   if (gSteam) gSteam.__prevSteamSpeed = params.handSteamSpeed;
      // })();
      // ---------- END HANDS + HAND STEAM ----------

      // If server parameters were restored, send them up
      pushServerParams();

      // --- APPLY RAIN SETTINGS FROM PRESET ---
      (() => {
        // 1) Count ‚Üí ensure buffers match
        const wantCount = (params.rainCount | 0);
        if (!rainVX || rainVX.length !== wantCount) {
          rebuildRain(wantCount);
        }

        // 2) Size ‚Üí update material
        if (rainMat) {
          rainMat.size = params.rainSize;
          rainMat.needsUpdate = true;
        }

        // 3) Speed ‚Üí scale existing velocities so it takes effect immediately
        if (rainVX && typeof params.rainSpeed === "number") {
          const prev = (gRain && gRain.__prevSpeed) ? gRain.__prevSpeed : 1;
          if (prev > 0 && prev !== params.rainSpeed) {
            const scale = params.rainSpeed / prev;
            for (let i = 0; i < rainVX.length; i++) {
              rainVX[i] *= scale; rainVY[i] *= scale; rainVZ[i] *= scale;
            }
          }
          if (gRain) gRain.__prevSpeed = params.rainSpeed;
        }
      })();
      // --- END RAIN SETTINGS ---
    }

    // --- Source & cameras ---
    if (state.ui) {
      if (state.ui.source) { params.source = state.ui.source; setBarsState(); }
      if (state.ui.browserCamId) { currentCamId = state.ui.browserCamId; }

      if (params.source === SOURCE.PythonWS) startWSStream();
      else startWebcamStream(currentCamId);

      if (wsConnected && state.ui.serverSelectedIndex != null) {
        try { ws.send(JSON.stringify({ cmd: "set_cam", index: Number(state.ui.serverSelectedIndex) })); } catch {}
      }
    }

    // --- External model transforms (best-effort by id, fallback by name) ---
    if (Array.isArray(state.models)) {
      state.models.forEach(m => {
        const rec =
        externalGroups.find(g => g.id === m.id) ||
        externalGroups.find(g => g.name === m.name);
        if (!rec) return;
        rec.group.position.set(m.t.x, m.t.y, m.t.z);
        rec.group.rotation.set(m.r.x, m.r.y, m.r.z);
        rec.group.scale.setScalar(m.s);
        rec.visible = !!m.visible;
        rec.group.visible = rec.visible;
        if (typeof m.density === "number") resampleGroupDensity(rec, m.density);
      });
      rebuildGroupsGUI();
      updateExternalPointMaterials();
    }

    if (!silent && paused) renderer.render(scene, camera);
  } catch (e) {
    console.warn("[state] applyState failed", e);
  }
}






function getDB(){
  if (_dbPromise) return _dbPromise;
  _dbPromise = new Promise((resolve, reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)){
        db.createObjectStore(STORE, { keyPath: "name" });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror   = () => reject(req.error);
  });
  return _dbPromise;
}

async function idbPutPreset(name, state){
  const db = await getDB();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE, "readwrite");
    tx.objectStore(STORE).put({ name, state, ts: Date.now() });
    tx.oncomplete = resolve; tx.onerror = ()=>reject(tx.error);
  });
}
async function idbGetPreset(name){
  const db = await getDB();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE, "readonly");
    const req = tx.objectStore(STORE).get(name);
    req.onsuccess = ()=> resolve(req.result?.state || null);
    req.onerror   = ()=> reject(req.error);
  });
}
async function idbDeletePreset(name){
  const db = await getDB();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE, "readwrite");
    tx.objectStore(STORE).delete(name);
    tx.oncomplete = resolve; tx.onerror = ()=>reject(tx.error);
  });
}
async function idbListPresets(){
  const db = await getDB();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE, "readonly");
    const req = tx.objectStore(STORE).getAll();
    req.onsuccess = ()=> resolve((req.result || []).map(r => ({name:r.name, ts:r.ts})));
    req.onerror   = ()=> reject(req.error);
  });
}

// Local autosave
const LS_LAST = "ld_last_state";
let _autosaveTimer = 0;
function scheduleAutosave(){
  clearTimeout(_autosaveTimer);
  _autosaveTimer = setTimeout(()=>{
    try { localStorage.setItem(LS_LAST, JSON.stringify(currentState())); }
    catch(e){ console.warn("[autosave] failed", e); }
  }, 250);
}
function tryLoadAutosave(){
  try{
    const raw = localStorage.getItem(LS_LAST);
    if (raw) applyState(JSON.parse(raw), {silent:true});
  } catch(e){ console.warn("[autosave] load failed", e); }
}



// Any GUI change or camera move => autosave
gui.onChange(() => { scheduleAutosave(); });
controls.addEventListener("change", scheduleAutosave);
window.addEventListener("beforeunload", scheduleAutosave);






  // Smooth alpha fade - WIP


function attachSteamShader(mat){
  const user = mat.userData;
  user.steamUniforms = {
    uTime:        { value: 0 },
    uDepthNoise:  { value: params.handSteamDepthNoise },
    uTurbHz:      { value: params.handSteamTurbulenceHz },
    uAlphaMode:   { value: 2 } // 0:linear, 1:smoothstep, 2:smootherstep
  };

  const prevOBC = mat.onBeforeCompile;
  mat.onBeforeCompile = (shader)=>{
    // chain any previous hook (e.g., depth fade)
    if (prevOBC) prevOBC(shader);

    // wire uniforms up
    shader.uniforms.uTime       = user.steamUniforms.uTime;
    shader.uniforms.uDepthNoise = user.steamUniforms.uDepthNoise;
    shader.uniforms.uTurbHz     = user.steamUniforms.uTurbHz;
    shader.uniforms.uAlphaMode  = user.steamUniforms.uAlphaMode;

    // ---- VERTEX: declare uniforms + attributes and add wobble ----
    shader.vertexShader = shader.vertexShader
      // declare our uniforms at top
    .replace(
      'void main() {',
      `
uniform float uTime;
uniform float uDepthNoise;
uniform float uTurbHz;

attribute float aSize;
attribute float aAge;
attribute float aSeed;
varying float vAge;

void main() {
      `
      )
      // pass age + z wobble
    .replace(
      '#include <begin_vertex>',
      `
#include <begin_vertex>
vAge = aAge;

// depth wobble: subtle z noise to fake volume
float wob = sin(aSeed + uTime * 6.28318 * uTurbHz) * uDepthNoise;
transformed.z += wob;
      `
      )
      // scale point size by per-particle size attribute
    .replace(
      'gl_PointSize = size;',
      'gl_PointSize = size * aSize;'
      );

    // ---- FRAGMENT: declare uniform + alpha curve ----
    shader.fragmentShader = shader.fragmentShader
    .replace(
      'void main() {',
      `
uniform int uAlphaMode;
varying float vAge;

float alphaCurve(float t){
  t = clamp(t, 0.0, 1.0);
  if (uAlphaMode==0) return t;
  if (uAlphaMode==1) return t*t*(3.0-2.0*t);                // smoothstep
  return t*t*t*(t*(6.0*t-15.0)+10.0);                       // smootherstep
}

void main() {
      `
      )
    .replace(
      '#include <alphatest_fragment>',
      `
#include <alphatest_fragment>
// fade-in then out: map age 0..1 to a bell curve
float a = (vAge < 0.5) ? alphaCurve(vAge*2.0) : alphaCurve((1.0 - vAge)*2.0);
diffuseColor.a *= a;
      `
      );
  };

  mat.needsUpdate = true;
  return mat;
}


function attachDepthFadeToPointsMaterial(mat){
  // uniforms live on userData so we can tweak from GUI
  const uniforms = mat.userData.depthFadeUniforms || {
    uFadeStart: { value: params.fadeStart },
    uFadeEnd:   { value: params.fadeEnd },
    uEnabled:   { value: params.fadeEnabled ? 1 : 0 },
    uDither:    { value: params.fadeDither ? 1 : 0 }
  };
  mat.userData.depthFadeUniforms = uniforms;

  mat.transparent = true;            // needed for smooth alpha fade
  // keep your existing alphaTest logic for sprite shapes; it plays fine with dither

  mat.onBeforeCompile = (shader) => {
    // hook our uniforms in
    shader.uniforms.uFadeStart = uniforms.uFadeStart;
    shader.uniforms.uFadeEnd   = uniforms.uFadeEnd;
    shader.uniforms.uEnabled   = uniforms.uEnabled;
    shader.uniforms.uDither    = uniforms.uDither;

    // pass view-space depth from vertex to fragment
    shader.vertexShader = shader.vertexShader
    .replace(
      'void main() {',
      `
        varying float vDepth; // positive distance from camera
        void main() {
      `
      )
    .replace(
      '#include <begin_vertex>',
      `
        #include <begin_vertex>
        vec3 mvPosition3 = (modelViewMatrix * vec4( transformed, 1.0 )).xyz;
        vDepth = -mvPosition3.z;
      `
      );



    // fade + optional dither in fragment
    shader.fragmentShader = shader.fragmentShader
    .replace(
      'void main() {',
      `
    varying float vDepth;
    // renamed to avoid colliding with three's own rand()
    float hash12(vec2 p){
      return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);
    }
    void main() {
      `
      )
    .replace(
      '#include <dithering_fragment>',
      `
    #include <dithering_fragment>
    if (uEnabled > 0){
      // smooth fade: 1 near, 0 far
      float fade = smoothstep(uFadeEnd, uFadeStart, vDepth);

      #ifndef ALPHATEST
      // multiply alpha for blended fade
      diffuseColor.a *= fade;
      #endif

      // optional screen-door dither to avoid sorting artifacts
      if (uDither > 0){
        float r = hash12(gl_FragCoord.xy);
        if (r > diffuseColor.a) discard;
      }
    }
      `
      );




  };

  mat.needsUpdate = true;
  return mat;
}

function updateDepthFadeUniforms(mat){
  const u = mat.userData.depthFadeUniforms;
  if (!u) return;
  u.uFadeStart.value = Math.min(params.fadeStart, params.fadeEnd);
  u.uFadeEnd.value   = Math.max(params.fadeStart, params.fadeEnd);
  u.uEnabled.value   = params.fadeEnabled ? 1 : 0;
  u.uDither.value    = params.fadeDither ? 1 : 0;
}

function updateDepthFadeAll(){
  // main cloud
  updateDepthFadeUniforms(cloudMaterial);
  // external point clouds
  externalGroups.forEach(g => updateDepthFadeUniforms(g.material));
  if (paused) renderer.render(scene,camera);
}



    // ---------- Cloud ----------

const cloudMaterial = new THREE.PointsMaterial({
  size: params.pointSize,
  vertexColors: true,
  sizeAttenuation: true,
  transparent: true
});
attachDepthFadeToPointsMaterial(cloudMaterial);



const cloudGeom = new THREE.BufferGeometry();
const cloudPoints = new THREE.Points(cloudGeom, cloudMaterial);
cloudGroup.add(cloudPoints);

// let lastPos=null, nextPos=null, curPos=null, curCol=null, baseCol=null;
// let tweenT = 1, targetTweenMs = 120, lastArrival = performance.now();


let lastPos=null, nextPos=null, curPos=null, curCol=null, baseCol=null;

// Build/Dissolve still use tween for their finite animations:
let tweenT = 1, targetTweenMs = 120;

// Live smoothing (continuous, no restarts):
let lastArrival = performance.now();
let tauMs = 140;      // time constant for EMA (ms)
let emaInit = false;  // first-packet guard

// Spring smoothing (snappier than EMA)
let velPos = null;                 // Float32Array same length as curPos
const springK = 40;                // stiffness (try 20..80)
const springC = 2 * Math.sqrt(springK); // critical damping



// point sprite textures
let shapeTexture = null;
function makeCircleTexture(size=64, feather=1.5){
  const c = document.createElement('canvas'); c.width=c.height=size;
  const ctx=c.getContext('2d'); const cx=size/2, cy=size/2, r=size/2-1;
  const img=ctx.createImageData(size,size);
  for(let y=0;y<size;y++)for(let x=0;x<size;x++){
    const dx=x-cx+0.5, dy=y-cy+0.5, d=Math.sqrt(dx*dx+dy*dy);
    let a = 1 - (d - (r-1)) * feather / 3; a=Math.max(0,Math.min(1,a));
    const i=(y*size+x)*4; img.data[i+3]=Math.round(a*255); img.data[i]=img.data[i+1]=img.data[i+2]=255;
  }
  ctx.putImageData(img,0,0);
  const tex=new THREE.CanvasTexture(c); tex.minFilter=tex.magFilter=THREE.LinearFilter; tex.wrapS=tex.wrapT=THREE.ClampToEdgeWrapping; return tex;
}
function makeCrossTexture(size=64, thickness=0.22, feather=1.25){
  const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
  const img=ctx.createImageData(size,size); const half=size/2; const halfBar=(thickness*size)*0.5;
  const smooth=(e0,e1,x)=>{const t=Math.max(0,Math.min(1,(x-e0)/(e1-e0)));return t*t*(3-2*t);}
  for(let y=0;y<size;y++)for(let x=0;x<size;x++){
    const dx=x+0.5-half, dy=y+0.5-half;
    const av=1-smooth(0,feather,Math.max(0,Math.abs(dx)-halfBar));
    const ah=1-smooth(0,feather,Math.max(0,Math.abs(dy)-halfBar));
    const a=Math.max(0,Math.min(1,Math.max(av,ah)));
    const i=(y*size+x)*4; img.data[i+3]=Math.round(a*255); img.data[i]=img.data[i+1]=img.data[i+2]=255;
  }
  ctx.putImageData(img,0,0);
  const tex=new THREE.CanvasTexture(c); tex.minFilter=tex.magFilter=THREE.LinearFilter; tex.wrapS=tex.wrapT=THREE.ClampToEdgeWrapping; return tex;
}

function makeSteamTexture(kind="soft", size=64){
  const c = document.createElement('canvas'); c.width=c.height=size;
  const ctx = c.getContext('2d');
  const img = ctx.createImageData(size, size);
  const cx=size/2, cy=size/2, r=size*0.48;

  const putA = (x,y,a)=>{
    const i=(y*size+x)*4; img.data[i]=img.data[i+1]=img.data[i+2]=255; img.data[i+3]=Math.max(0,Math.min(255,Math.round(a*255)));
  };

  for (let y=0;y<size;y++) for (let x=0;x<size;x++){
    const dx=x+0.5-cx, dy=y+0.5-cy;
    const d=Math.hypot(dx,dy)/r;

    let a=0;
    if (kind==="soft"){
      // gentle gaussian-ish blob
      const t=Math.max(0,1-d);
      a = Math.pow(t, 2.2);
    } else if (kind==="circle"){
      a = d<=1 ? 1 : 0;
    } else if (kind==="triangle"){
      // soft triangular-ish falloff
      const t=Math.max(0,1-d);
      a = Math.pow(t, 1.3);
    } else { // "spark"
      const ang = Math.atan2(dy,dx);
      const rays = Math.abs(Math.cos(ang*4.0))*0.6+0.4;
      const t = Math.max(0, 1 - d*rays);
      a = Math.pow(t, 2.0);
    }
    putA(x,y,a);
  }

  ctx.putImageData(img,0,0);
  const tex=new THREE.CanvasTexture(c);
  tex.minFilter=tex.magFilter=THREE.LinearFilter;
  tex.wrapS=tex.wrapT=THREE.ClampToEdgeWrapping;
  return tex;
}



    // --- NEW BLOCK: External model groups state (place after params) ---
    let externalGroups = []; // [{ id, name, group, points, material, basePositions, baseColors, density, visible }]
    let groupIdSeq = 1;
    let selectedGroupId = null;

    // Shared TransformControls for positioning models
    const tControls = new TransformControls(camera, renderer.domElement);
    tControls.setMode("translate"); // default; user can toggle in GUI
    tControls.addEventListener('dragging-changed', e => { controls.enabled = !e.value && !renderer.xr.isPresenting; });

    // scene.add(tControls);

    // With this:
    const addControlsRoot = () => {
      const root = tControls._root || tControls; // future-proof
      if (root.parent !== scene) scene.add(root);
    };
    addControlsRoot();


    function selectExternalGroup(id) {
      selectedGroupId = id;
      const rec = externalGroups.find(g => g.id === id);
      if (rec) {
        addControlsRoot();        // make sure gizmo root is in the scene
        tControls.attach(rec.group);
      } else {
        tControls.detach();
        // optional: remove the gizmo from the scene when nothing is selected
        if (tControls._root?.parent) tControls._root.parent.remove(tControls._root);
      }
    }


    // Keep point size/shape of all external point clouds in sync with main params


    // function makePointMaterialFromParams() {
    //   const mat = new THREE.PointsMaterial({
    //     size: params.pointSize,
    //     vertexColors: true,
    //     sizeAttenuation: true,
    //     transparent: (params.pointShape !== "square"),
    //     map: (shapeTexture || null),
    //     alphaTest: (params.pointShape === "square" ? 0.0 : 0.5)
    //   });
    //   return mat;
    // }

// --- SINGLE ATTRACTOR SPHERE ---
    const attractorSphere = new THREE.Mesh(
      new THREE.SphereGeometry(0.05, 16, 12),
      new THREE.MeshBasicMaterial({ color: 0xff55aa, wireframe: true })
      );
    
    //attractorSphere.position.set(0, params.xrYOffset, -0.6);
    attractorSphere.position.set(0, 1.7, -0.6);  

    attractorSphere.visible = params.handSteamAttractEnabled;
    scene.add(attractorSphere);

// --- Hand pinch grabbing for the attractorSphere ---
let grabbedByHand = null;                 // which hand currently holds the sphere (hand0/hand1), or null
const GRAB_EXTRA_RADIUS = 0.01;           // extra leniency around the sphere
const _wposTip = new THREE.Vector3();
const _wposSphere = new THREE.Vector3();

function fingertipOf(hand){
  return hand?.joints?.['index-finger-tip'] || null;
}
function isTipNearSphere(hand){
  if (!hand || !attractorSphere || !attractorSphere.visible) return false;
  const tip = fingertipOf(hand); if (!tip) return false;
  tip.getWorldPosition(_wposTip);
  attractorSphere.getWorldPosition(_wposSphere);
  const sphereR = (attractorSphere.geometry.boundingSphere?.radius || 0.05) * attractorSphere.scale.x;
  return _wposTip.distanceTo(_wposSphere) <= (sphereR + GRAB_EXTRA_RADIUS);
}
function grabSphere(hand){
  if (!hand || grabbedByHand) return;
  const tip = fingertipOf(hand); if (!tip) return;
  // Reparent while preserving world transform
  tip.attach(attractorSphere);
  grabbedByHand = hand;
  // hide the gizmo while grabbed
  try { tControls.detach(); } catch {}
}
function releaseSphere(){
  if (!grabbedByHand) return;
  // Put back under the scene while preserving world transform
  scene.attach(attractorSphere);
  grabbedByHand = null;
}





// Make it grabbable with the existing gizmo:
(() => {
  // small helper in the Models folder would be fine, but here's a quick toggle:
  const g = gui.addFolder("Attractor Control");
  g.add({ select: ()=> tControls.attach(attractorSphere) }, "select").name("Select Attractor");
  g.add({ detach: ()=> tControls.detach() }, "detach").name("Detach Gizmo");
})();






function makePointMaterialFromParams() {
  const mat = new THREE.PointsMaterial({
    size: params.pointSize,
    vertexColors: true,
    sizeAttenuation: true,
    transparent: (params.pointShape !== "square"),
    map: (shapeTexture || null),
    alphaTest: (params.pointShape === "square" ? 0.0 : 0.5)
  });
  attachDepthFadeToPointsMaterial(mat);
  return mat;
}



function updateExternalPointMaterials() {
  externalGroups.forEach(g => {
    g.material.size = params.pointSize;
    g.material.map = (shapeTexture || null);
    g.material.alphaTest = (params.pointShape === "square" ? 0.0 : 0.5);
        g.material.transparent = true;  // <‚Äî
        g.material.depthWrite  = false; // <‚Äî
        g.material.needsUpdate = true;
      });
}

    // --- END NEW BLOCK ---


function setPointShape(){
  if (shapeTexture){ shapeTexture.dispose(); shapeTexture=null; }

  if (params.pointShape==="square"){
    cloudMaterial.map = null;
    cloudMaterial.alphaTest = 0.0;
  } else if (params.pointShape==="circle"){
    shapeTexture = makeCircleTexture(64, params.shapeFeather);
    cloudMaterial.map = shapeTexture;
    cloudMaterial.alphaTest = 0.5;
      } else { // cross
        shapeTexture = makeCrossTexture(64, params.crossThickness, params.shapeFeather);
        cloudMaterial.map = shapeTexture;
        cloudMaterial.alphaTest = 0.5;
      }

      // important: keep blending path enabled so fade works
      cloudMaterial.transparent = true;       // <‚Äî
      cloudMaterial.depthWrite  = false;      // helps with sorting of translucent points
      cloudMaterial.needsUpdate = true;

      updateExternalPointMaterials();
      if (paused) renderer.render(scene,camera);
    }



//     function setPointShape(){


// // --- REPLACE BODY OF setPointShape() (keep your function name/signature) ---
//       if (shapeTexture){ shapeTexture.dispose(); shapeTexture=null; }
//       if (params.pointShape==="square"){
//         cloudMaterial.map=null; cloudMaterial.alphaTest=0; cloudMaterial.transparent=false;
//       } else if (params.pointShape==="circle"){
//         shapeTexture=makeCircleTexture(64,params.shapeFeather);
//         cloudMaterial.map=shapeTexture; cloudMaterial.alphaTest=0.5; cloudMaterial.transparent=true;
//       } else {
//         shapeTexture=makeCrossTexture(64,params.crossThickness,params.shapeFeather);
//         cloudMaterial.map=shapeTexture; cloudMaterial.alphaTest=0.5; cloudMaterial.transparent=true;
//       }
//       cloudMaterial.needsUpdate=true;
//       updateExternalPointMaterials();
//       if (paused) renderer.render(scene,camera);
// // --- END REPLACE ---


//       // if (shapeTexture){ shapeTexture.dispose(); shapeTexture=null; }

//       // if (params.pointShape==="square"){ cloudMaterial.map=null; cloudMaterial.alphaTest=0; cloudMaterial.transparent=false; }
//       // else if (params.pointShape==="circle"){ shapeTexture=makeCircleTexture(64,params.shapeFeather); cloudMaterial.map=shapeTexture; cloudMaterial.alphaTest=0.5; cloudMaterial.transparent=true; }
//       // else { shapeTexture=makeCrossTexture(64,params.crossThickness,params.shapeFeather); cloudMaterial.map=shapeTexture; cloudMaterial.alphaTest=0.5; cloudMaterial.transparent=true; }

//       // cloudMaterial.needsUpdate=true; if (paused) renderer.render(scene,camera);


//     }


    setPointShape();

    function ensureCloudBuffers(N){
      const needAlloc = !cloudGeom.getAttribute('position') || cloudGeom.getAttribute('position').count !== N;
      if (needAlloc){
        curPos=new Float32Array(N*3); curCol=new Float32Array(N*3); baseCol=new Float32Array(N*3);
        lastPos=new Float32Array(N*3); nextPos=new Float32Array(N*3);
        cloudGeom.setAttribute('position', new THREE.BufferAttribute(curPos,3));
        cloudGeom.setAttribute('color',    new THREE.BufferAttribute(curCol,3));
      } else {
        curPos=cloudGeom.getAttribute('position').array; curCol=cloudGeom.getAttribute('color').array;
        if (!baseCol || baseCol.length!==curCol.length) baseCol=new Float32Array(curCol.length);
        if (!lastPos || lastPos.length!==curPos.length) lastPos=new Float32Array(curPos.length);
        if (!nextPos || nextPos.length!==curPos.length) nextPos=new Float32Array(curPos.length);
      }
      if (!dissolveVel || dissolveVel.length!==curPos.length) dissolveVel=new Float32Array(curPos.length);
    }

    // ---------- Frame parsing / colors ----------
    function parseFrame(buffer){
      const dv = new DataView(buffer);
      const headerLen = dv.getUint32(0, true);
      let offset = 4;
      if (headerLen === 0) return { hello:true };
      const headerStr = new TextDecoder().decode(new Uint8Array(buffer, offset, headerLen));
      offset += headerLen; const mis = offset & 3; if (mis) offset += (4 - mis);
      const header = JSON.parse(headerStr);
      const N = header.w * header.h;
      const depth = new Float32Array(buffer, offset, N); offset += N * 4;
      const rgb = new Uint8Array(buffer, offset, N * 3);
      return { header, depth, rgb };
    }

    function luma(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }
    function rotateHue(r,g,b, deg){
      const a=deg*Math.PI/180, cosA=Math.cos(a), sinA=Math.sin(a);
      const m=[
        0.299+0.701*cosA+0.168*sinA, 0.587-0.587*cosA+0.330*sinA, 0.114-0.114*cosA-0.497*sinA,
        0.299-0.299*cosA-0.328*sinA, 0.587+0.413*cosA+0.035*sinA, 0.114-0.114*cosA+0.292*sinA,
        0.299-0.300*cosA+1.250*sinA, 0.587-0.588*cosA-1.050*sinA, 0.114+0.886*cosA-0.203*sinA
      ];
      return [ m[0]*r+m[1]*g+m[2]*b, m[3]*r+m[4]*g+m[5]*b, m[6]*r+m[7]*g+m[8]*b ];
    }

    function applyFilter(dst, src){
      const mode=params.filter, tint=params.tintAmount, gain=params.brightness, ctr=params.contrast;
      const doClamp=params.clamp, doBW=params.bwEnabled, thr=params.bwThreshold, hueDeg=params.hue|0;
      for (let i=0;i<src.length;i+=3){
        let r=src[i], g=src[i+1], b=src[i+2];
        if (mode===FILTERS.Monochrome){ const y=luma(r,g,b); r=g=b=y; }
        else if (mode===FILTERS.Invert){ r=1-r; g=1-g; b=1-b; }
        else if (mode===FILTERS["Invert+Mono"]){ const y=1-luma(r,g,b); r=g=b=y; }
        else if (mode===FILTERS["Tint Red"]){ g*=(1-0.55*tint); b*=(1-0.55*tint); }
        else if (mode===FILTERS["Red‚ÜíYellow"]){ const t=luma(r,g,b); r=1; g=t; b=0; }
        if (hueDeg){ const v=rotateHue(r,g,b,hueDeg); r=v[0]; g=v[1]; b=v[2]; }
        r=(r*gain - 0.5)*ctr + 0.5; g=(g*gain - 0.5)*ctr + 0.5; b=(b*gain - 0.5)*ctr + 0.5;
        if (doBW){ const y=luma(r,g,b); r=g=b=(y>=thr)?1:0; }
        if (doClamp){ r=Math.min(1,Math.max(0,r)); g=Math.min(1,Math.max(0,g)); b=Math.min(1,Math.max(0,b)); }
        dst[i]=r; dst[i+1]=g; dst[i+2]=b;
      }
    }

    function unprojectInto(targetArray, colorArray, header, depth, rgb){
      const { w,h, fx,fy, cx,cy } = header; let k=0, c=0;
      for (let v=0; v<h; v++) for (let u=0; u<w; u++){
        const i=v*w+u; const Z=depth[i];
        const X=(u-cx)/fx*Z; const Y=(v-cy)/fy*Z;
        targetArray[k++]= X; targetArray[k++]=-Y; targetArray[k++]=-Z;
        baseCol[i*3]=rgb[c++]/255; baseCol[i*3+1]=rgb[c++]/255; baseCol[i*3+2]=rgb[c++]/255;
      }
      applyFilter(curCol, baseCol);
    }





    // ---------- Collision + Rain ----------
    const CELL=0.03, SAMPLE_STRIDE=3, COLLISION_RADIUS=0.045;


    let occGrid=new Map();
    let cloudBounds={ center:new THREE.Vector3(0,0,-1.2), radius:0.8 };
    const keyFrom=(ix,iy,iz)=>`${ix},${iy},${iz}`;

    function rebuildGridFromCloud(){
      occGrid.clear(); if (!nextPos) return;
      const L=nextPos.length/3;
      let minx=Infinity,miny=Infinity,minz=Infinity,maxx=-Infinity,maxy=-Infinity,maxz=-Infinity;
      for (let i=0;i<L;i+=SAMPLE_STRIDE){
        const x=nextPos[3*i], y=nextPos[3*i+1], z=nextPos[3*i+2];
        if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) continue;
        const ix=Math.floor(x/CELL), iy=Math.floor(y/CELL), iz=Math.floor(z/CELL);
        const k=keyFrom(ix,iy,iz); if (!occGrid.has(k)) occGrid.set(k,{x,y,z});
        if (x<minx)minx=x; if (y<miny)miny=y; if (z<minz)minz=z;
        if (x>maxx)maxx=x; if (y>maxy)maxy=y; if (z>maxz)maxz=z;
      }
      if (isFinite(minx)){
        const cx=(minx+maxx)/2, cy=(miny+maxy)/2, cz=(minz+maxz)/2;
        const rx=(maxx-minx)/2, ry=(maxy-miny)/2, rz=(maxz-minz)/2;
        cloudBounds.center.set(cx,cy,cz);
        cloudBounds.radius=Math.max(rx,ry,rz)||0.8;
      }
    }

    const NEIGH=[]; for (let dz=-1;dz<=1;dz++) for (let dy=-1;dy<=1;dy++) for (let dx=-1;dx<=1;dx++) NEIGH.push([dx,dy,dz]);
    function collidesWithCloud(x,y,z){
      const ix=Math.floor(x/CELL), iy=Math.floor(y/CELL), iz=Math.floor(z/CELL);
      const r2=COLLISION_RADIUS*COLLISION_RADIUS;
      for (const [dx,dy,dz] of NEIGH){
        const p=occGrid.get(keyFrom(ix+dx,iy+dy,iz+dz)); if (!p) continue;
        const dxp=x-p.x, dyp=y-p.y, dzp=z-p.z; if (dxp*dxp+dyp*dyp+dzp*dzp<=r2) return true;
      }
      return false;
    }






    // const RAIN_COUNT=1200, GRAVITY_BASE=1.6, HIT_FLASH_MS=180, STICK_MS=700, RAIN_SPREAD=1.2;
    // const BEHAVIOUR={ STICK:1, FLY_UP:2, RADIAL:3, RANDOM:4 }; let behaviour=BEHAVIOUR.STICK;

    // const rainGeom=new THREE.BufferGeometry();
    // const rainPos=new Float32Array(RAIN_COUNT*3);
    // const rainCol=new Float32Array(RAIN_COUNT*3);
    // const rainVX=new Float32Array(RAIN_COUNT), rainVY=new Float32Array(RAIN_COUNT), rainVZ=new Float32Array(RAIN_COUNT);
    // const rainFlash=new Float32Array(RAIN_COUNT), rainStick=new Float32Array(RAIN_COUNT), rainBounce=new Float32Array(RAIN_COUNT);

    // function respawnDrop(i){
    //   const R=cloudBounds.radius||0.8, c=cloudBounds.center, spread=R*RAIN_SPREAD;
    //   rainPos[3*i]=c.x+(Math.random()*2-1)*spread; rainPos[3*i+2]=c.z+(Math.random()*2-1)*spread; rainPos[3*i+1]=c.y+(R+0.6+Math.random()*0.4);
    //   const s=params.rainSpeed; rainVX[i]=0; rainVY[i]=-(0.6+Math.random()*0.4)*s; rainVZ[i]=0; rainFlash[i]=rainStick[i]=rainBounce[i]=0;
    //   rainCol[3*i]=0.5; rainCol[3*i+1]=0.7; rainCol[3*i+2]=1.0;
    // }
    // (function initRain(){
    //   for(let i=0;i<RAIN_COUNT;i++) respawnDrop(i);
    //     rainGeom.setAttribute('position', new THREE.BufferAttribute(rainPos,3));
    //   rainGeom.setAttribute('color', new THREE.BufferAttribute(rainCol,3));
    //   const rainMat=new THREE.PointsMaterial({ size:0.002, vertexColors:true, sizeAttenuation:true });
    //   const rainPoints = new THREE.Points(rainGeom, rainMat);
    //   cloudGroup.add(rainPoints);
    // })();


// --- RAIN: dynamic, GUI-tweakable count + size ---
    const GRAVITY_BASE = 1.6, HIT_FLASH_MS = 180, STICK_MS = 700, RAIN_SPREAD = 1.2;
    const BEHAVIOUR = { STICK:1, FLY_UP:2, RADIAL:3, RANDOM:4 }; let behaviour = BEHAVIOUR.STICK;

    let rainGeom = null, rainMat = null, rainPoints = null;
    let rainPos = null, rainCol = null, rainVX = null, rainVY = null, rainVZ = null, rainFlash = null, rainStick = null, rainBounce = null;

    function respawnDrop(i){
      const R = cloudBounds.radius || 0.8, c = cloudBounds.center, spread = R*RAIN_SPREAD;
      rainPos[3*i]   = c.x + (Math.random()*2-1)*spread;
      rainPos[3*i+2] = c.z + (Math.random()*2-1)*spread;
      rainPos[3*i+1] = c.y + (R+0.6+Math.random()*0.4);

      const s = params.rainSpeed;
      rainVX[i] = 0; rainVY[i] = -(0.6+Math.random()*0.4)*s; rainVZ[i] = 0;
      rainFlash[i] = 0; rainStick[i] = 0; rainBounce[i] = 0;

      rainCol[3*i] = 0.5; rainCol[3*i+1] = 0.7; rainCol[3*i+2] = 1.0;
    }

    function rebuildRain(count){
      count = Math.max(0, Math.min(20000, count|0));

  // remove old
      if (rainPoints){
        cloudGroup.remove(rainPoints);
        rainGeom?.dispose();
        rainMat?.dispose();
      }

  // allocate
      rainGeom = new THREE.BufferGeometry();
      rainPos  = new Float32Array(count*3);
      rainCol  = new Float32Array(count*3);
      rainVX   = new Float32Array(count);
      rainVY   = new Float32Array(count);
      rainVZ   = new Float32Array(count);
      rainFlash= new Float32Array(count);
      rainStick= new Float32Array(count);
      rainBounce=new Float32Array(count);

      for (let i=0;i<count;i++) respawnDrop(i);

        rainGeom.setAttribute('position', new THREE.BufferAttribute(rainPos,3));
      rainGeom.setAttribute('color',    new THREE.BufferAttribute(rainCol,3));

      rainMat = new THREE.PointsMaterial({
        size: params.rainSize,
        vertexColors: true,
        sizeAttenuation: true
      });

      rainPoints = new THREE.Points(rainGeom, rainMat);
      cloudGroup.add(rainPoints);
    }

// build once
    rebuildRain(params.rainCount);

    function impulseOnHit(i){
      rainFlash[i]=HIT_FLASH_MS;
      const x=rainPos[3*i], y=rainPos[3*i+1], z=rainPos[3*i+2], c=cloudBounds.center, s=params.rainSpeed;
      if (behaviour===BEHAVIOUR.STICK){ rainStick[i]=STICK_MS; rainVX[i]=rainVY[i]=rainVZ[i]=0; }
      else if (behaviour===BEHAVIOUR.FLY_UP){ rainVY[i]=(3.2+Math.random()*0.8)*s; rainVX[i]=(Math.random()*2-1)*0.3*s; rainVZ[i]=(Math.random()*2-1)*0.3*s; rainBounce[i]=450; }
      else if (behaviour===BEHAVIOUR.RADIAL){ let dx=x-c.x,dy=y-c.y,dz=z-c.z; const L=Math.hypot(dx,dy,dz)||1; dx/=L; dy/=L; dz/=L; const sp=(2.4+Math.random()*0.8)*s; rainVX[i]=dx*sp; rainVY[i]=dy*sp; rainVZ[i]=dz*sp; rainBounce[i]=600; }
      else { let dx=Math.random()*2-1,dy=Math.random()*2-1,dz=Math.random()*2-1; const L=Math.hypot(dx,dy,dz)||1; dx/=L; dy/=L; dz/=L; const sp=(2.2+Math.random()*1.2)*s; rainVX[i]=dx*sp; rainVY[i]=dy*sp; rainVZ[i]=dz*sp; rainBounce[i]=500; }
    }

    function stepRain(dt){
      if (!rainVX) return;
      const count = rainVX.length;
      const R = (cloudBounds.radius||0.8)+0.5, floorY=cloudBounds.center.y-R, grav=GRAVITY_BASE*params.rainSpeed;
      for (let i=0;i<count;i++){
        const base=3*i;
        if (rainStick[i]>0){ rainStick[i]-=dt*1000; rainFlash[i]=Math.max(rainFlash[i],40); }
        else {
          let g=grav; if (rainBounce[i]>0){ g*=0.25; rainBounce[i]-=dt*1000; }
          rainVY[i]-=g*dt; rainPos[base]+=rainVX[i]*dt; rainPos[base+1]+=rainVY[i]*dt; rainPos[base+2]+=rainVZ[i]*dt;
          if (collidesWithCloud(rainPos[base],rainPos[base+1],rainPos[base+2])) impulseOnHit(i);
        }
        if (rainFlash[i]>0){
          rainFlash[i]-=dt*1000; const t=Math.max(0,Math.min(1,rainFlash[i]/HIT_FLASH_MS));
          rainCol[base]=1.0*t+0.5*(1-t); rainCol[base+1]=0.1*t+0.7*(1-t); rainCol[base+2]=0.1*t+1.0*(1-t);
        } else if (rainStick[i]<=0){ rainCol[base]=0.5; rainCol[base+1]=0.7; rainCol[base+2]=1.0; }
        const c=cloudBounds.center;
        const far=Math.hypot(rainPos[base]-c.x,rainPos[base+1]-c.y,rainPos[base+2]-c.z)>(cloudBounds.radius+2.5);
        if ((rainStick[i]<=0 && rainPos[base+1]<floorY) || far) respawnDrop(i);
      }
      rainGeom.getAttribute('position').needsUpdate=true; rainGeom.getAttribute('color').needsUpdate=true;
    }


// --- HAND STEAM PARTICLES ---
  let handSteamGeom = null, handSteamPoints = null;  // handSteamMat was declared earlier
  let hsPos=null, hsCol=null, hsVel=null, hsLife=null;
  let handSteamNext=0; // circular writer index



  function rebuildHandSteam(count){
    count = Math.max(0, Math.min(20000, count | 0));

    if (handSteamPoints){
      scene.remove(handSteamPoints);
      handSteamGeom?.dispose();
      handSteamMat?.dispose();
    }

    handSteamGeom = new THREE.BufferGeometry();
    hsPos  = new Float32Array(count * 3);
    hsCol  = new Float32Array(count * 3);
    hsVel  = new Float32Array(count * 3);
    hsLife = new Float32Array(count);
  hsAge  = new Float32Array(count);        // 0..1
  hsSize = new Float32Array(count);        // per-particle multiplier
  hsSeed = new Float32Array(count);        // random phase for wobble
  hsLifeTotal = new Float32Array(count);   // to compute age fraction

  const [cr,cg,cb] = params.handSteamColor;
  for (let i=0;i<count;i++){
    const b=3*i;
    hsPos[b]=hsPos[b+1]=hsPos[b+2]=9999;
    hsVel[b]=hsVel[b+1]=hsVel[b+2]=0;
    hsLife[i]=0;
    hsAge[i]=0;
    hsSize[i]=1;
    hsSeed[i]=Math.random()*1000.0;
    hsLifeTotal[i]=1;
    hsCol[b]=cr; hsCol[b+1]=cg; hsCol[b+2]=cb;
  }

  const aPos = new THREE.BufferAttribute(hsPos,3);
  const aCol = new THREE.BufferAttribute(hsCol,3);
  aPos.setUsage?.(THREE.DynamicDrawUsage);
  aCol.setUsage?.(THREE.DynamicDrawUsage);

  handSteamGeom.setAttribute('position', aPos);
  handSteamGeom.setAttribute('color',    aCol);
  handSteamGeom.setAttribute('aSize', new THREE.BufferAttribute(hsSize,1));
  handSteamGeom.setAttribute('aAge',  new THREE.BufferAttribute(hsAge,1));
  handSteamGeom.setAttribute('aSeed', new THREE.BufferAttribute(hsSeed,1));

  const ar = isARSession();
  handSteamMat = new THREE.PointsMaterial({
    size: ar ? params.handSteamSizePx : params.handSteamSizeWorld,
    vertexColors: true,
    sizeAttenuation: !ar,
    transparent: true,
    depthWrite: false,
    map: makeSteamTexture(params.handSteamShape)
  });

  attachDepthFadeToPointsMaterial(handSteamMat);
  attachSteamShader(handSteamMat);

  handSteamPoints = new THREE.Points(handSteamGeom, handSteamMat);
  handSteamPoints.frustumCulled = false;
  handSteamPoints.visible = !!params.handSteamEnabled;
  scene.add(handSteamPoints);

  handSteamNext = 0;
  syncComputedHandSizes();
  applyHandSteamSize();
}


// Build once from current preset
rebuildHandSteam(params.handSteamCount | 0);



// helper: gather current joint world positions
const _jtmp = new THREE.Vector3();
function gatherHandJointPositions(){
  const out = [];
  [hand0, hand1].forEach(h=>{
    const js = h?.joints ? Object.values(h.joints) : null;
    if (!js) return;
    for (let j=0;j<js.length;j++){
      js[j].getWorldPosition(_jtmp);
      out.push(_jtmp.x, _jtmp.y, _jtmp.z);
    }
  });
  return out; // flat [x,y,z,...]
}

// spawn N particles around random joints
function spawnHandSteam(n){
  if (!hsPos || !n) return;
  const joints = gatherHandJointPositions();
  const J = Math.floor(joints.length/3);
  if (!J) return;

  const spread = params.handSteamSpread;
  for (let k=0;k<n;k++){
    const j = (Math.random()*J)|0, j3=j*3;
    const jx=joints[j3], jy=joints[j3+1], jz=joints[j3+2];

    let ox,oy,oz,L;
    do { ox=Math.random()*2-1; oy=Math.random()*2-1; oz=Math.random()*2-1; L=ox*ox+oy*oy+oz*oz; } while (L>1 || L===0);
    ox*=spread; oy*=spread; oz*=spread;

    const i = handSteamNext;
    handSteamNext = (handSteamNext + 1) % hsLife.length;
    const b=3*i;

    hsPos[b]   = jx + ox;
    hsPos[b+1] = jy + oy;
    hsPos[b+2] = jz + oz;

    // BEFORE: const up = params.handSteamUpVel * params.handSteamSpeed;
    const up = params.handSteamUpVel;  // NO speed factor here

    hsVel[b]   = (Math.random()*2-1) * up*0.15;
    hsVel[b+1] = up * (0.6 + Math.random()*0.6);
    hsVel[b+2] = (Math.random()*2-1) * up*0.15;

    // Lifespan: scale by time-scale so wall-clock life stays the same
    // const baseLife = 0.9 + Math.random()*1.0;     // your original distribution (seconds)
    // const s        = Math.max(0, params.handSteamSpeed);
    // const lifeSim  = baseLife * s;                // sim-time life so (lifeSim / s) == baseLife (wall-clock)
    // hsLife[i]      = lifeSim;
    // hsLifeTotal[i] = lifeSim;
    // hsAge[i]       = 0.0;

    // REPLACE this in spawnHandSteam(...)
    const baseLife = 0.9 + Math.random()*1.0;
    const lifeSim  = baseLife;      // ‚Üê no speed factor
    hsLife[i]      = lifeSim;
    hsLifeTotal[i] = lifeSim;
    hsAge[i]       = 0.0;



    const smin = Math.min(params.handSteamSizeMin, params.handSteamSizeMax);
    const smax = Math.max(params.handSteamSizeMin, params.handSteamSizeMax);
    hsSize[i] = smin + Math.random()*(smax - smin);

        // randomize wobble phase a bit more
    hsSeed[i] = Math.random()*1000.0;
  }

  handSteamGeom.getAttribute('aSize').needsUpdate = true;
  handSteamGeom.getAttribute('aSeed').needsUpdate = true;
}


// step simulation (with turbulent attractor strength & range)
function stepHandSteam(dt){
  if (!handSteamPoints || !params.handSteamEnabled) return;

  // --- time-scale (ONLY place speed applies) ---
  const s   = Math.max(0, params.handSteamSpeed);
  const dts = dt * s;

  // --- births: scale by speed to keep density roughly constant across speeds ---
  const births = Math.min(((params.handSteamBirthsPerFrame | 0) * (s || 0)), hsLife.length);
  if (births > 0) spawnHandSteam(births | 0);

  // --- attractor setup (no hidden speed multipliers) ---
  const attractON = params.handSteamAttractEnabled && attractorSphere?.visible;
  let ax = 0, ay = 0, az = 0;
  if (attractON){
    ax = attractorSphere.position.x;
    ay = attractorSphere.position.y;
    az = attractorSphere.position.z;
  }

  // base (unmodulated) params
  const maxDBase   = Math.max(1e-6, params.handSteamAttractMax);
  const strength01 = params.handSteamAttractStrength; // NO * s

  // turbulence knobs (safe defaults if not present)
  const turbAmp = Math.max(0, params.handSteamAttractTurbAmp ?? 0);             // 0..1
  const turbHz  = Math.max(0, params.handSteamAttractTurbHz  ?? 0);             // Hz
  const rangeJ  = Math.max(0, params.handSteamAttractRangeJitter ?? 0);         // 0..1

  // --- drag uses scaled dt ---
  const drag = Math.max(0, params.handSteamDrag);
  const damp = Math.exp(-drag * dts);

  // small sine-noise helper (maps to ~[0,1])
  const TWO_PI = Math.PI * 2;
  const noise01 = (ph) => {
    const n = Math.sin(ph) + 0.5 * Math.sin(ph * 1.7 + 1.234);
    return 0.5 + n / 3.0;
  };

  for (let i = 0, n = hsLife.length; i < n; i++){
    if (hsLife[i] <= 0) continue;

    // age in scaled time (so visuals time-stretch with speed)
    hsLife[i] -= dts;
    hsAge[i]   = 1.0 - Math.max(0, hsLife[i]) / Math.max(1e-5, hsLifeTotal[i]);

    const b = 3 * i;

    // attractor (with turbulence)
    if (attractON){
      const dx = ax - hsPos[b];
      const dy = ay - hsPos[b + 1];
      const dz = az - hsPos[b + 2];
      const d  = Math.hypot(dx, dy, dz);

      // per-particle phase from seed + global steamTime
      const ph = hsSeed[i] + steamTime * TWO_PI * turbHz;

      // wobble around 1.0: 1 ¬± turbAmp
      const wobble = 1.0 + turbAmp * (noise01(ph) * 2.0 - 1.0);

      // range jitter around 1.0, clamped so it stays positive
      const rangeMul = Math.max(0.05, 1.0 + rangeJ * (noise01(ph + 4.2) * 2.0 - 1.0));
      const maxD     = maxDBase * rangeMul;
      const invMax   = 1.0 / maxD;

      if (d > 1e-4 && d < maxD){
        const t   = 1.0 - d * invMax;              // 0..1 inside radius
        const acc = strength01 * wobble * t;       // modulated strength
        const invd = 1.0 / d;

        hsVel[b]   += dx * invd * acc * dts;      // integrate with dts
        hsVel[b+1] += dy * invd * acc * dts;
        hsVel[b+2] += dz * invd * acc * dts;
      }
    }

    // drag + integrate with scaled time
    hsVel[b]   *= damp; hsVel[b+1] *= damp; hsVel[b+2] *= damp;
    hsPos[b]   += hsVel[b]   * dts;
    hsPos[b+1] += hsVel[b+1] * dts;
    hsPos[b+2] += hsVel[b+2] * dts;

    // safety kill if it explodes numerically or flies away
    if (!Number.isFinite(hsPos[b]) || !Number.isFinite(hsPos[b+1]) || !Number.isFinite(hsPos[b+2]) ||
      Math.abs(hsPos[b]) + Math.abs(hsPos[b+1]) + Math.abs(hsPos[b+2]) > 100) {
      hsLife[i] = 0;
  }
}

  // push attributes
const aPos = handSteamGeom.getAttribute('position');
const aAge = handSteamGeom.getAttribute('aAge');
if (aPos) aPos.needsUpdate = true;
if (aAge) aAge.needsUpdate = true;

  // allow live shape swap (unchanged)
if (handSteamMat && handSteamMat.mapKind !== params.handSteamShape){
  handSteamMat.map = makeSteamTexture(params.handSteamShape);
  handSteamMat.mapKind = params.handSteamShape;
  handSteamMat.needsUpdate = true;
}
}








    // ---------- Transitions / Export / Keys ----------
function startBuild(){ if (!curPos||!nextPos) return;
if (!dissolveVel||dissolveVel.length!==curPos.length) dissolveVel=new Float32Array(curPos.length);
const R=(cloudBounds.radius||0.8)*2.5, c=cloudBounds.center;
for (let i=0;i<lastPos.length;i+=3){
  let rx=Math.random()*2-1, ry=Math.random()*2-1, rz=Math.random()*2-1; const L=Math.hypot(rx,ry,rz)||1; rx/=L; ry/=L; rz/=L;
  const d=(0.3+Math.random()*0.7)*R; lastPos[i]=c.x+rx*d; lastPos[i+1]=c.y+ry*d; lastPos[i+2]=c.z+rz*d;
  curPos[i]=lastPos[i]; curPos[i+1]=lastPos[i+1]; curPos[i+2]=lastPos[i+2];
}
cloudGeom.getAttribute('position').needsUpdate=true; cloudGeom.computeBoundingSphere();
targetTweenMs=BUILD_MS; tweenT=0; transitionMode=TRANSITION.BUILD;
cloudMaterial.transparent=true; cloudMaterial.opacity=1; cloudMaterial.needsUpdate=true;
statusText=`Build: tweening in ${BUILD_MS}ms`;
}

function startDissolve(){ if (!curPos) return;
if (!dissolveVel||dissolveVel.length!==curPos.length) dissolveVel=new Float32Array(curPos.length);
const c=cloudBounds.center, speedBase=DISSOLVE_SPEED*Math.max(1,cloudBounds.radius||1);
for (let i=0;i<curPos.length;i+=3){
  let dx=curPos[i]-c.x, dy=curPos[i+1]-c.y, dz=curPos[i+2]-c.z;
  if (!(isFinite(dx)&&isFinite(dy)&&isFinite(dz)) || (Math.abs(dx)+Math.abs(dy)+Math.abs(dz)<1e-6)){ dx=Math.random()*2-1; dy=Math.random()*2-1; dz=Math.random()*2-1; }
  const L=Math.hypot(dx,dy,dz)||1; dx/=L; dy/=L; dz/=L; const s=speedBase*(0.6+Math.random()*1.4);
  dissolveVel[i]=dx*s; dissolveVel[i+1]=dy*s; dissolveVel[i+2]=dz*s;
}
dissolveElapsed=0; transitionMode=TRANSITION.DISSOLVE;
cloudMaterial.transparent=true; cloudMaterial.opacity=1; cloudMaterial.needsUpdate=true;
statusText=`Dissolve: flying out for ${DISSOLVE_MS}ms`;
}

function resetTransition(){
  transitionMode=TRANSITION.NORMAL; dissolveElapsed=0;
  if (curPos && lastPos){ lastPos.set(curPos); tweenT=1; }
  cloudMaterial.transparent=true; cloudMaterial.opacity=1; cloudMaterial.needsUpdate=true;
  statusText="Live: normal tweening";
}


// Save Blob

function saveBlob(blob, filename){ const url=URL.createObjectURL(blob); const a=document.createElement("a"); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),1000); }
function timestamp(){ const ts=new Date(), pad=n=>String(n).padStart(2,"0"); return `${ts.getFullYear()}-${pad(ts.getMonth()+1)}-${pad(ts.getDate())}_${pad(ts.getHours())}-${pad(ts.getMinutes())}_${pad(ts.getSeconds())}`; }

function buildMeshFromGrid(curPos, curCol, w, h, exportStride=2, maxEdge=0.08){
  if (!curPos||!curCol||!w||!h) return null; const W=w,H=h,s=Math.max(1,exportStride);
  const nx=Math.floor((W-1)/s)+1, ny=Math.floor((H-1)/s)+1; const positions=[], colors=[], indexMap=new Int32Array(nx*ny).fill(-1);
  const idxG=(yy,xx)=>yy*W+xx, idxM=(j,i)=>j*nx+i; let vcount=0;
  for (let j=0,y=0;j<ny;j++,y+=s){ if (y>=H) y=H-1;
    for (let i=0,x=0;i<nx;i++,x+=s){ if (x>=W) x=W-1;
      const gi=idxG(y,x)*3; const X=curPos[gi], Y=curPos[gi+1], Z=curPos[gi+2];
    if (!Number.isFinite(X)||!Number.isFinite(Y)||!Number.isFinite(Z)){ indexMap[idxM(j,i)]=-1; continue; }
    positions.push(X,Y,Z); const r=curCol[gi]??1, g=curCol[gi+1]??1, b=curCol[gi+2]??1; colors.push(r,g,b); indexMap[idxM(j,i)]=vcount++;
  }
}
const vIdx=(j,i)=>indexMap[idxM(j,i)];
      const d2=(ax,ay,az,bx,by,bz)=>{const dx=ax-bx,dy=ay-by,dz=ax-bz;return (ax-bx)*(ax-bx)+(ay-by)*(ay-by)+(az-bz)*(az-bz);} // safe inline
      const maxE2=maxEdge*maxEdge;
      const indices=[];
      for (let j=0;j<ny-1;j++) for (let i=0;i<nx-1;i++){
        const i00=vIdx(j,i),i10=vIdx(j,i+1),i01=vIdx(j+1,i),i11=vIdx(j+1,i+1); if (i00<0||i10<0||i01<0||i11<0) continue;
        indices.push(i00,i10,i01, i10,i11,i01);
      }
      if (!positions.length || !indices.length) return null;
      const geo=new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
      geo.setAttribute('color',    new THREE.Float32BufferAttribute(colors,3));
      geo.setIndex(indices);
      geo.computeVertexNormals();
      const mat=new THREE.MeshStandardMaterial({ vertexColors:true, roughness:1, metalness:0 });
      return new THREE.Mesh(geo,mat);
    }

    function buildPointsNodeFromCloud(){
      if (!cloudGeom||!cloudGeom.attributes?.position) return null;
      const mat=new THREE.PointsMaterial({ size:params.pointSize, vertexColors:true, sizeAttenuation:true });
      return new THREE.Points(cloudGeom.clone(), mat);
    }


// --- NEW BLOCK: GLTF -> point cloud + density utilities ---
    function gltfToPoints(gltf, { name="Model", density=1.0 } = {}) {
  // Collect raw positions/colors from all meshes
      const pos = [];
      const col = [];
      const tmpColor = new THREE.Color(1,1,1);
      gltf.scene.traverse(node => {
        if (!node.isMesh || !node.geometry) return;
        const geo = node.geometry;
        geo.computeBoundingSphere?.();

    // Pull positions in world space
        const posAttr = geo.getAttribute('position');
        if (!posAttr) return;

    // Try vertex colors first, else material color (if any)
        const colorAttr = geo.getAttribute('color');
        let matColor = tmpColor;
        if (node.material && node.material.color) matColor.copy(node.material.color);

    // Build a temp matrix to bake node transform
        node.updateWorldMatrix(true, false);
        const m = node.matrixWorld;

        for (let i = 0; i < posAttr.count; i++) {
          const vx = posAttr.getX(i), vy = posAttr.getY(i), vz = posAttr.getZ(i);
      // world transform
          const wx = m.elements[0]*vx + m.elements[4]*vy + m.elements[8]*vz  + m.elements[12];
          const wy = m.elements[1]*vx + m.elements[5]*vy + m.elements[9]*vz  + m.elements[13];
          const wz = m.elements[2]*vx + m.elements[6]*vy + m.elements[10]*vz + m.elements[14];
          pos.push(wx, wy, wz);

          if (colorAttr) {
            col.push(colorAttr.getX(i) || 1, colorAttr.getY(i) || 1, colorAttr.getZ(i) || 1);
          } else {
            col.push(matColor.r, matColor.g, matColor.b);
          }
        }
      });

      if (pos.length === 0) {
        console.warn("[viewer] GLTF had no mesh vertices to convert to points.");
      }

  // Optionally downsample to target density (0..1), random keep
      let basePositions = new Float32Array(pos);
      let baseColors    = new Float32Array(col);
      if (density < 1.0 && density > 0) {
        const keep = Math.max(1, Math.floor((basePositions.length/3) * density));
        const idx = new Uint32Array(basePositions.length/3);
        for (let i=0;i<idx.length;i++) idx[i]=i;
    // Fisher‚ÄìYates shuffle first K
          for (let i=0;i<keep;i++){
            const j = i + Math.floor(Math.random() * (idx.length - i));
            const t = idx[i]; idx[i] = idx[j]; idx[j] = t;
          }
          const outP=new Float32Array(keep*3), outC=new Float32Array(keep*3);
          for (let k=0;k<keep;k++){
            const s = idx[k]*3, d=k*3;
            outP[d]=basePositions[s]; outP[d+1]=basePositions[s+1]; outP[d+2]=basePositions[s+2];
            outC[d]=baseColors[s]; outC[d+1]=baseColors[s+1]; outC[d+2]=baseColors[s+2];
          }
          basePositions = outP; baseColors = outC;
        }

  // Build Points geometry/material
        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.BufferAttribute(basePositions.slice(), 3));
        geom.setAttribute('color',    new THREE.BufferAttribute(baseColors.slice(),    3));
        const material = makePointMaterialFromParams();
        const points = new THREE.Points(geom, material);

  // Group to carry transforms
        const group = new THREE.Group();
        group.add(points);

  // Record
        return {
          id: groupIdSeq++,
          name,
          group,
          points,
          material,
          basePositions,
          baseColors,
          density: Math.max(0.001, Math.min(1, density)),
          visible: true
        };
      }

// Resample an existing group's density (0..1), updates its Points geometry in-place
      function resampleGroupDensity(rec, density) {
        density = Math.max(0.001, Math.min(1, density));
        rec.density = density;

        const total = rec.basePositions.length/3;
        const keep = Math.max(1, Math.floor(total * density));
        const idx = new Uint32Array(total);
        for (let i=0;i<idx.length;i++) idx[i]=i;
          for (let i=0;i<keep;i++){
            const j = i + Math.floor(Math.random() * (idx.length - i));
            const t = idx[i]; idx[i] = idx[j]; idx[j] = t;
          }
          const outP=new Float32Array(keep*3), outC=new Float32Array(keep*3);
          for (let k=0;k<keep;k++){
            const s = idx[k]*3, d=k*3;
            outP[d]=rec.basePositions[s]; outP[d+1]=rec.basePositions[s+1]; outP[d+2]=rec.basePositions[s+2];
            outC[d]=rec.baseColors[s];    outC[d+1]=rec.baseColors[s+1];    outC[d+2]=rec.baseColors[s+2];
          }
          rec.points.geometry.setAttribute('position', new THREE.BufferAttribute(outP,3));
          rec.points.geometry.setAttribute('color',    new THREE.BufferAttribute(outC,3));
          rec.points.geometry.attributes.position.needsUpdate = true;
          rec.points.geometry.attributes.color.needsUpdate = true;
          rec.points.geometry.computeBoundingSphere();
        }

// Add group to scene + registry
        function addExternalGroup(rec) {
          cloudGroup.add(rec.group);
          externalGroups.push(rec);
  rebuildGroupsGUI(); // refresh the ‚ÄúModels‚Äù panel
}
// --- END NEW BLOCK ---




function exportGLB({ exportStride=2, maxEdge=0.08 }={}){
  if (!lastHeader||!curPos||!curCol) return; const {w,h}=lastHeader;
  const mesh=buildMeshFromGrid(curPos,curCol,w,h,exportStride,maxEdge);
  const node=mesh||buildPointsNodeFromCloud(); if (!node) return;
  const exp=new GLTFExporter();
  exp.parse(node,(res)=>{
    const isAB=Object.prototype.toString.call(res)==="[object ArrayBuffer]";
    const blob=isAB? new Blob([res],{type:"model/gltf-binary"}): res;
    const name=`pointcloud_${timestamp()}.glb`; saveBlob(blob, name);
    if (mesh){ mesh.geometry.dispose(); mesh.material.dispose(); }
  },{binary:true,embedImages:true,onlyVisible:true,includeCustomExtensions:true});
}

function exportGLTF_JSON({ exportStride=2, maxEdge=0.08 }={}){
  if (!lastHeader||!curPos||!curCol) return; const {w,h}=lastHeader;
  const node=buildMeshFromGrid(curPos,curCol,w,h,exportStride,maxEdge)||buildPointsNodeFromCloud(); if (!node) return;
  const exp=new GLTFExporter();
  exp.parse(node,(json)=>{
    const pretty=JSON.stringify(json,null,2);
    saveBlob(new Blob([pretty],{type:"application/json"}),`pointcloud_${timestamp()}.gltf`);
  },{binary:false,embedImages:true,onlyVisible:true,includeCustomExtensions:true});
}

    // Keyboard shortcuts (unchanged)
// window.addEventListener("keydown",(e)=>{ const k=e.key.toLowerCase();
//   if (k==="p") togglePause(); else if (k==="s") savePNG(); else if (k==="f") toggleFullscreen();
//   else if (k==="1") setBehaviour(1); else if (k==="2") setBehaviour(2); else if (k==="3") setBehaviour(3); else if (k==="4") setBehaviour(4);
//   else if (k==="g"&&!e.shiftKey) exportGLB({exportStride:2,maxEdge:0.08});
//   else if (k==="g"&&e.shiftKey) exportGLTF_JSON({exportStride:2,maxEdge:0.08});
//   else if (k==="t"){ cycleFilter(); }
//   else if (k==="b") startBuild(); else if (k==="d") startDissolve(); else if (k==="r") resetTransition();
// });

// --- REPLACE YOUR ENTIRE keyboard listener WITH THIS BLOCK ---
window.addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();

  // existing shortcuts
  if (k === "p") togglePause();
  else if (k === "s") savePNG();
  else if (k === "f") toggleFullscreen();
  else if (k === "1") setBehaviour(1);
  else if (k === "2") setBehaviour(2);
  else if (k === "3") setBehaviour(3);
  else if (k === "4") setBehaviour(4);
  else if (k === "g" && !e.shiftKey) exportGLB({ exportStride: 2, maxEdge: 0.08 });
  else if (k === "g" && e.shiftKey)  exportGLTF_JSON({ exportStride: 2, maxEdge: 0.08 });
  else if (k === "t") { cycleFilter(); }
  else if (k === "b") startBuild();
  else if (k === "d") startDissolve();

  // keep your old 'r' behavior for reset
  else if (k === "r" && !e.shiftKey) resetTransition();

  // --- NEW: TransformControls modes ---
  else if (k === "w") tControls.setMode("translate");
  else if (k === "e") tControls.setMode("rotate");
  else if (k === "r" && e.shiftKey) tControls.setMode("scale");

  // --- NEW: cycle selection across external groups ---
  else if (e.key === "ArrowRight") {
    if (externalGroups.length) {
      const idx = Math.max(0, externalGroups.findIndex(g => g.id === selectedGroupId));
      const next = externalGroups[(idx + 1) % externalGroups.length];
      selectExternalGroup(next.id);
    }
  } else if (e.key === "ArrowLeft") {
    if (externalGroups.length) {
      const idx = Math.max(0, externalGroups.findIndex(g => g.id === selectedGroupId));
      const prev = externalGroups[(idx - 1 + externalGroups.length) % externalGroups.length];
      selectExternalGroup(prev.id);
    }
  }
});
// --- END REPLACE ---



function togglePause(){ paused=!paused; statusText=(paused?"[PAUSED] ":"")+statusText; if (paused) renderer.render(scene,camera); }
function savePNG(){ try{ const url=renderer.domElement.toDataURL("image/png"); const a=document.createElement("a"); a.href=url; a.download=`pointcloud_${timestamp()}.png`; document.body.appendChild(a); a.click(); a.remove(); } catch(e){} }
async function toggleFullscreen(){ try{ if (!document.fullscreenElement) await document.body.requestFullscreen({navigationUI:"hide"}).catch(()=>document.body.requestFullscreen()); else await document.exitFullscreen(); } catch(e){} }
function setBehaviour(n){ behaviour=n; statusText=`mode=${n} (1=stick, 2=fly-up, 3=radial, 4=random)`; }
function reapplyFilter(){ if (!baseCol||!curCol) return; applyFilter(curCol,baseCol); const attr=cloudGeom.getAttribute('color'); if (attr) attr.needsUpdate=true; if (paused) renderer.render(scene,camera); }
function cycleFilter(){
  const values=Object.values(FILTERS);
  const idx=values.indexOf(params.filter);
  params.filter = values[(idx+1)%values.length];
  reapplyFilter();
}

    // NEW: hook buttons to same functions
const on = (el, fn) => el && el.addEventListener('click', fn, { passive:true });
on(btnPause, togglePause);
on(btnSave,  savePNG);
on(btnFull,  toggleFullscreen);
on(btnBuild, startBuild);
on(btnDissolve, startDissolve);
on(btnReset, resetTransition);
on(btnFilter, cycleFilter);
btnModeEls.forEach(b=> b.addEventListener('click', ()=> setBehaviour(Number(b.dataset.mode)), { passive:true }));

let lastFrameT=performance.now(), fpsCounter=0, fps=0, fpsT0=performance.now();

function frame(nowMs){
  const t = nowMs ?? performance.now();
  const dt = (t - lastFrameT) / 1000; 
  lastFrameT = t;

  // --- transitions ---
  if (transitionMode === TRANSITION.DISSOLVE && curPos && dissolveVel){
    const L = curPos.length;
    dissolveElapsed += dt;
    const tt = Math.min(1, dissolveElapsed / (DISSOLVE_MS / 1000));
    for (let i = 0; i < L; i++) curPos[i] += dissolveVel[i] * dt;
      cloudGeom.getAttribute('position').needsUpdate = true;
    cloudGeom.computeBoundingSphere();
    cloudMaterial.opacity = 1 - tt; 
    if (tt >= 1) cloudMaterial.opacity = 0;
  }
  if (transitionMode === TRANSITION.BUILD && tweenT >= 1) {
    transitionMode = TRANSITION.NORMAL;
  }

  if (!paused){
    // --- LIVE smoothing (EMA only) ---
    if (transitionMode === TRANSITION.NORMAL && curPos && nextPos && curPos.length === nextPos.length){
      const alpha = 1 - Math.exp(-(dt * 1000) / Math.max(1, tauMs)); // frame-rate independent
      const L = curPos.length;
      for (let i = 0; i < L; i++){
        curPos[i] += (nextPos[i] - curPos[i]) * alpha;
      }
      cloudGeom.getAttribute('position').needsUpdate = true;
      cloudGeom.computeBoundingSphere();
    }

    // rain + render
    stepRain(dt);
    stepHandSteam(dt);

    if (!renderer.xr.isPresenting) controls.update();


    // update hand point clouds (AR/VR)
    ensureHandPointsExist();
    updateHandPoints(hand0, hand0Points);
    updateHandPoints(hand1, hand1Points);


    // advance steam shader time + reflect GUI changes live
    if (handSteamPoints?.material?.userData?.steamUniforms){
      const u = handSteamPoints.material.userData.steamUniforms;
      
      steamTime += dt * Math.max(0, params.handSteamSpeed);   // accumulate scaled time
      u.uTime.value       = steamTime;                        // wobble runs slower/faster
      u.uDepthNoise.value = params.handSteamDepthNoise;
      u.uTurbHz.value     = params.handSteamTurbulenceHz;     // leave frequency as-is

      u.uAlphaMode.value =
      (params.handSteamAlphaMode==="linear") ? 0 :
      (params.handSteamAlphaMode==="smoothstep") ? 1 : 2;
    }

    renderer.render(scene, camera);
  }

  // --- HUD / FPS ---
  fpsCounter++;
  const now = performance.now();
  if (now - fpsT0 >= 1000){
    fps = fpsCounter; 
    fpsCounter = 0; 
    fpsT0 = now;
    overlay.textContent = `${statusText} | ${fps} fps | [1..4] modes ¬∑ [P]ause ¬∑ [S]ave ¬∑ [F]ullscreen ¬∑ [G]/[Shift+G] export`;
  }
}


// function frame(nowMs){
//   const t=nowMs ?? performance.now();
//   const dt=(t-lastFrameT)/1000; lastFrameT=t;

//   if (transitionMode===TRANSITION.DISSOLVE && curPos && dissolveVel){
//     const L=curPos.length; dissolveElapsed+=dt; const tt=Math.min(1,dissolveElapsed/(DISSOLVE_MS/1000));
//     for (let i=0;i<L;i++) curPos[i]+=dissolveVel[i]*dt; cloudGeom.getAttribute('position').needsUpdate=true; cloudGeom.computeBoundingSphere();
//       cloudMaterial.opacity=1-tt; if (tt>=1) cloudMaterial.opacity=0;
//   }
//   if (transitionMode===TRANSITION.BUILD && tweenT>=1) transitionMode=TRANSITION.NORMAL;

//   // if (!paused){
//   //   if (tweenT<1 && curPos && nextPos && lastPos){
//   //     const step=(dt*1000)/Math.max(1,targetTweenMs); tweenT=Math.min(1,tweenT+step);
//   //     const L=curPos.length, a=1-tweenT, b=tweenT; for (let i=0;i<L;i++) curPos[i]=a*lastPos[i]+b*nextPos[i];
//   //     cloudGeom.getAttribute('position').needsUpdate=true; cloudGeom.computeBoundingSphere();
//   //   }
//   //   stepRain(dt);

//   //   if (!renderer.xr.isPresenting) controls.update();
//   //   renderer.render(scene,camera);
//   // }


//   if (!paused){
//     // 4a) BUILD transition keeps using finite tween (easing)


//     // 4b) LIVE smoothing: mass‚Äìspring‚Äìdamper toward nextPos (snappier, still smooth)
//     if (transitionMode === TRANSITION.NORMAL && curPos && nextPos && curPos.length === nextPos.length){
//       if (!velPos || velPos.length !== curPos.length) velPos = new Float32Array(curPos.length);

//       const k = springK, c = springC; // stiffness & damping
//       const L = curPos.length;
//       for (let i = 0; i < L; i++) {
//         const x  = curPos[i];      // current
//         const v  = velPos[i];      // velocity
//         const xT = nextPos[i];     // target
//         const a  = k * (xT - x) - c * v; // acceleration
//         velPos[i] = v + a * dt;         // integrate velocity
//         curPos[i] = x + velPos[i] * dt; // integrate position
//       }

//       cloudGeom.getAttribute('position').needsUpdate = true;
//       cloudGeom.computeBoundingSphere();
//     }


//     // 4b) LIVE smoothing: continuous EMA toward latest nextPos (no restarts)
//     if (transitionMode === TRANSITION.NORMAL && curPos && nextPos && curPos.length === nextPos.length){
//       const alpha = 1 - Math.exp(-(dt * 1000) / Math.max(1, tauMs)); // frame-rate independent
//       const L = curPos.length;
//       for (let i=0; i<L; i++){
//         curPos[i] += (nextPos[i] - curPos[i]) * alpha;
//       }
//       cloudGeom.getAttribute('position').needsUpdate = true;
//       cloudGeom.computeBoundingSphere();
//     }

//     stepRain(dt);
//     if (!renderer.xr.isPresenting) controls.update();
//     renderer.render(scene, camera);
//   }

//   fpsCounter++; const now=performance.now();
//   if (now-fpsT0>=1000){ fps=fpsCounter; fpsCounter=0; fpsT0=now; overlay.textContent=`${statusText} | ${fps} fps | [1..4] modes ¬∑ [P]ause ¬∑ [S]ave ¬∑ [F]ullscreen ¬∑ [G]/[Shift+G] export`; }
// }

    // XR render loop
renderer.setAnimationLoop(frame);

    // ---------- WS + browser/server camera controls ----------
let ws=null, wsConnected=false, wsURLs=[], wsTry=0, wsTimer=null;
let camStream=null, camVideo=null, camCnv=null, camCtx=null, camTimer=null;
let currentCamId="";

refreshBtn.addEventListener("click", async ()=>{ await populateCameraList(true); });
camSelect.addEventListener("change", async ()=>{ currentCamId=camSelect.value||""; if (params.source===SOURCE.BrowserCam) startWebcamStream(currentCamId); });

srvRefresh.addEventListener("click", ()=>{ if (wsConnected) ws.send(JSON.stringify({cmd:"list_cams"})); });
srvSelect.addEventListener("change", ()=>{ const idx = Number(srvSelect.value); if (wsConnected) ws.send(JSON.stringify({cmd:"set_cam", index: idx})); });

function setBarsState(){
  const wsMode = params.source===SOURCE.PythonWS;
  serverBar.classList.toggle("muted", !wsMode || !wsConnected);
  browserBar.classList.toggle("muted", wsMode);
}

async function populateCameraList(force=false){
  try{
    if (force || (await navigator.permissions?.query?.({name:"camera"}).catch(()=>null))?.state!=="granted"){
      try{ const tmp=await navigator.mediaDevices.getUserMedia({video:true,audio:false}); tmp.getTracks().forEach(t=>t.stop()); }catch{}
    }
    const devices=await navigator.mediaDevices.enumerateDevices();
    const cams=devices.filter(d=>d.kind==="videoinput");
    const prev=camSelect.value; camSelect.innerHTML="";
    cams.forEach((d,i)=>{ const opt=document.createElement("option"); opt.value=d.deviceId; opt.textContent=d.label||`Camera ${i+1}`; camSelect.appendChild(opt); });
    const toSel=cams.find(c=>c.deviceId===prev)? prev : (cams[0]?.deviceId||"");
    camSelect.value=toSel; if (!currentCamId) currentCamId=toSel;
  }catch(e){ console.warn("populateCameraList failed", e); }
}

function stopWS(){ if (ws){ try{ ws.close(); }catch{} ws=null; } wsConnected=false; setBarsState(); }
function stopWebcam(){ if (camTimer) cancelAnimationFrame(camTimer); camTimer=null; if (camVideo){ camVideo.pause(); camVideo.srcObject=null; camVideo=null; } if (camStream){ camStream.getTracks().forEach(t=>t.stop()); camStream=null; } camCnv=camCtx=null; }

// function wsURLSameOrigin() {
//   const dev = new URLSearchParams(location.search).get("ws");
//   if (dev) return dev;
//   const proto = (location.protocol === "https:") ? "wss" : "ws";
//       // Nginx exposes the tunnel at /livedepth-ws/
//   return `${proto}://${location.host}/livedepth-ws/`;
// }

function wsURL() {
  const qp = new URLSearchParams(location.search);
  const forced = qp.get("ws");            // manual override
  if (forced) return forced;

  const proto = (location.protocol === "https:") ? "wss" : "ws";

  // When served from flaboy.com/livedepth ‚Üí go through Nginx subpath
  if (location.pathname.startsWith("/livedepth")) {
    return `${proto}://${location.host}/livedepth-ws/`;
  }

  // Local app mode ‚Üí talk straight to the WS server port
  const port = Number(qp.get("port") || "8765");
  const host = location.hostname;     // keep hostname; avoid mixing with :8443
  return `${proto}://${host}:${port}/`;
}



function startWSStream(){
  stopWebcam(); stopWS();

  let attempt = 0;
  const backoffBase = 500, backoffMax = 4000;

  const tryConnect = () => {
    const url = wsURL();  // <-- use the new function
    attempt++;
    statusText = `WS connecting ${url} (attempt ${attempt})`;
    overlay.classList.add("error");
    overlay.textContent = statusText;

    const sock = new WebSocket(url);
    ws = sock; ws.binaryType = "arraybuffer";

    sock.onopen = () => {
      wsConnected = true; setBarsState();
      statusText = `connected (${url})`;
      overlay.classList.remove("error");
      overlay.textContent = statusText;
      try { ws.send(JSON.stringify({ cmd:"list_cams" })); } catch {}
      try { ws.send(JSON.stringify({ cmd:"get_params" })); } catch {}

    };

    sock.onmessage = (ev) => {
      if (typeof ev.data === "string") {
        try {
          const msg = JSON.parse(ev.data);

          if (msg.type === "cams") {
            srvSelect.innerHTML = "";
            msg.items.forEach(it => {
              const o = document.createElement("option");
              o.value = String(it.index);
              o.textContent = `[${it.index}] ${it.name}`;
              srvSelect.appendChild(o);
            });
            if (msg.selected != null) srvSelect.value = String(msg.selected);
            setBarsState();

          } else if (msg.type === "set_cam_ok") {
            srvSelect.value = String(msg.index);

          } else if (msg.type === "set_cam_err") {
            console.warn("Server set_cam failed:", msg.error);

      // --- NEW: live server parameter updates ---
          } else if (msg.type === "params" || msg.type === "params_ok") {
            if (typeof msg.ema_alpha  === "number") params.serverEmaAlpha  = msg.ema_alpha;
            if (typeof msg.clamp_near === "number") params.serverClampNear = msg.clamp_near;
            if (typeof msg.clamp_far  === "number") params.serverClampFar  = msg.clamp_far;
        // refresh GUI fields without re-triggering onChange
            try { gServer?.controllers?.forEach?.(c => c.updateDisplay?.()); } catch {}

          } else if (msg.type === "params_err") {
            console.warn("Server param error:", msg.error);
          }
      // --- end NEW ---

        } catch(e) {
          console.warn("JSON msg parse error", e);
        }
        return;
      }

  // Binary frame
      const parsed = parseFrame(ev.data);
      if (parsed.hello) return;
      onNewNetworkFrame(parsed);
    };


    sock.onerror = (e) => { console.warn("[viewer] ws error", e); };

    sock.onclose = () => {
      wsConnected = false; setBarsState();
      const d = Math.min(backoffMax, backoffBase * Math.pow(1.6, Math.min(attempt, 6)));
      statusText = `DISCONNECTED ¬∑ retrying in ${Math.round(d)}ms`;
      overlay.classList.add("error");
      overlay.textContent = statusText;
      setTimeout(tryConnect, d);
    };
  };

  tryConnect();
}

async function startWebcamStream(deviceId=""){
  stopWS(); stopWebcam();
  try{
    const constraints = deviceId ? { video:{ deviceId:{ exact: deviceId } }, audio:false }
    : { video:{ facingMode:"user" }, audio:false };
    camStream = await navigator.mediaDevices.getUserMedia(constraints);
  }catch(e){
    statusText="camera denied/unavailable";
    overlay.classList.add("error"); overlay.textContent=statusText; return;
  }

  camVideo=document.createElement("video");
  camVideo.playsInline=true; camVideo.muted=true; camVideo.srcObject=camStream;
  await camVideo.play().catch(()=>{});
  camCnv=document.createElement("canvas"); camCtx=camCnv.getContext("2d",{willReadFrequently:true});

  const step=()=>{
    if (!camVideo || camVideo.readyState<2){ camTimer=requestAnimationFrame(step); return; }
    const W=Math.max(40, Math.min(params.camWidth|0, camVideo.videoWidth||640));
    const H=Math.round(W*(camVideo.videoHeight||480)/(camVideo.videoWidth||640))||1;
    camCnv.width=W; camCnv.height=H;

    camCtx.save();
    camCtx.translate(params.camFlipX?W:0, params.camFlipY?H:0);
    camCtx.scale(params.camFlipX?-1:1, params.camFlipY?-1:1);
    camCtx.drawImage(camVideo,0,0,W,H);
    camCtx.restore();

    const img=camCtx.getImageData(0,0,W,H);
    const stride=Math.max(1,params.camStride|0);
    const wS=Math.floor(W/stride), hS=Math.floor(H/stride), N=wS*hS;

    const depth=new Float32Array(N), rgb=new Uint8Array(N*3);
    let di=0, ri=0; const s=params.camDepthScale, off=params.camDepthOffset;

    for (let y=0;y<hS;y++) for (let x=0;x<wS;x++){
      const u=x*stride, v=y*stride, base=(v*W+u)*4;
      const r=img.data[base]/255, g=img.data[base+1]/255, b=img.data[base+2]/255;
      const Y=0.2126*r+0.7152*g+0.0722*b;
      const Z=off+(1-Y)*s;
      depth[di++]=Z;
      rgb[ri++]=Math.round(r*255); rgb[ri++]=Math.round(g*255); rgb[ri++]=Math.round(b*255);
    }

    const fx=0.5*wS/Math.tan((camera.fov*Math.PI/180)/2), fy=fx, cx=(wS-1)/2, cy=(hS-1)/2;
    const header={ w:wS, h:hS, fx, fy, cx, cy, stride, ts:performance.now() }; lastHeader=header;

    lastPos = lastPos && lastPos.length===N*3 ? lastPos : new Float32Array(N*3);
    nextPos = nextPos && nextPos.length===N*3 ? nextPos : new Float32Array(N*3);

    onNewNetworkFrame({ header, depth, rgb });
    camTimer=requestAnimationFrame(step);
  };

  step();
}

function onSourceChanged(){
  if (params.source===SOURCE.PythonWS){ startWSStream(); }
  else { startWebcamStream(currentCamId); }
  setBarsState();
}

function onNewNetworkFrame(parsed){
  const { header, depth, rgb } = parsed;
  const N = header.w * header.h;

  ensureCloudBuffers(N);
  lastPos.set(nextPos);                      // keep for BUILD transition
  unprojectInto(nextPos, curCol, header, depth, rgb);
  cloudGeom.getAttribute('color').needsUpdate = true;
  lastHeader = header;
  rebuildGridFromCloud();

  // Update smoothing time-constant (NO tween restart)
  const now = performance.now();
  const inter = Math.min(params.tweenMaxMs, Math.max(params.tweenMinMs, now - lastArrival));
  lastArrival = now;

  if (params.tweenAuto) {
    const a = params.tweenAlpha;
    tauMs = (1 - a) * tauMs + a * inter;
    tauMs = Math.min(params.tweenMaxMs, Math.max(params.tweenMinMs, tauMs));
  } else {
    tauMs = params.tweenMs | 0;
  }

  // First packet: snap and zero spring velocity
  if (!emaInit && curPos && nextPos && curPos.length === nextPos.length) {
    curPos.set(nextPos);
    if (velPos && velPos.length === curPos.length) velPos.fill(0);
    cloudGeom.getAttribute('position').needsUpdate = true;
    cloudGeom.computeBoundingSphere();
    emaInit = true;
  }


  statusText = `w=${header.w} h=${header.h} | œÑ‚âà${Math.round(tauMs)}ms | rain=${rainVX ? rainVX.length : 0}`;
}


async function bootstrap(){
  await populateCameraList(false);
      // Always default to PythonWS when served from /livedepth
  params.source = (location.pathname.startsWith("/livedepth")) ? SOURCE.PythonWS : params.source;

  if (params.source === SOURCE.PythonWS) startWSStream();
  else startWebcamStream(currentCamId);

  setBarsState();
  tryLoadAutosave();

}



// ---------- WebXR Buttons (default styling/placement) ----------
// document.body.appendChild( XRButton.createButton(renderer, {
//   optionalFeatures: ['local-floor','bounded-floor','hand-tracking','layers']
// }) );

// document.body.appendChild( ARButton.createButton(renderer, {
//   requiredFeatures: ['local-floor'],
//   optionalFeatures: []
// }) );



// create hands
// const handFactory = new XRHandModelFactory();

// const hand0 = renderer.xr.getHand(0);
// hand0.add(handFactory.createHandModel(hand0, 'mesh')); // 'mesh' | 'spheres' | 'boxes'
// scene.add(hand0);

// const hand1 = renderer.xr.getHand(1);
// hand1.add(handFactory.createHandModel(hand1, 'mesh'));
// scene.add(hand1);



// --- HANDS AS POINT CLOUDS ---
const handFactory = new XRHandModelFactory();
const hand0 = renderer.xr.getHand(0);
const hand1 = renderer.xr.getHand(1);
scene.add(hand0, hand1);

// build joint objects (spheres) so we get per-joint Object3Ds that track poses,
// then hide them; we'll render our own Points
const hand0Model = handFactory.createHandModel(hand0, 'spheres');
const hand1Model = handFactory.createHandModel(hand1, 'spheres');

hand0.add(hand0Model);
hand1.add(hand1Model);

hand0Model.visible = false;
hand1Model.visible = false;


// Pinch ‚Üí grab / release like the three.js example
hand0.addEventListener('pinchstart', () => { if (!grabbedByHand && isTipNearSphere(hand0)) grabSphere(hand0); });
hand1.addEventListener('pinchstart', () => { if (!grabbedByHand && isTipNearSphere(hand1)) grabSphere(hand1); });

hand0.addEventListener('pinchend',   () => { if (grabbedByHand === hand0) releaseSphere(); });
hand1.addEventListener('pinchend',   () => { if (grabbedByHand === hand1) releaseSphere(); });



// precompute unit offsets for max cluster size so we don't re-random each frame
const MAX_HAND_CLUSTER = 80;
const HAND_OFFSETS = (() => {
  const out = new Float32Array(MAX_HAND_CLUSTER * 3);
  for (let i=0;i<MAX_HAND_CLUSTER;i++){
    // random point on/inside unit sphere
    let x,y,z, L;
    do { x=Math.random()*2-1; y=Math.random()*2-1; z=Math.random()*2-1; L=x*x+y*y+z*z; } while (L>1 || L===0);
    out[i*3]=x; out[i*3+1]=y; out[i*3+2]=z;
  }
  return out;
})();

function makeHandPoints(hand) {
  const joints = hand.joints ? Object.values(hand.joints) : [];
  const nj = joints.length;
  if (!nj) return null;

  const k = Math.min(MAX_HAND_CLUSTER, Math.max(1, params.handClusterCount|0));
  const n = nj * k;

  const geom = new THREE.BufferGeometry();
  const pos  = new Float32Array(n * 3);
  const col  = new Float32Array(n * 3);

  // gentle blue; brightness applied later
  for (let i=0;i<n;i++){ col[i*3]=0.6; col[i*3+1]=0.8; col[i*3+2]=1.0; }

    geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geom.setAttribute('color',    new THREE.BufferAttribute(col, 3));

  const mat = makePointMaterialFromParams();

  // === CHANGED: pick sizing by session type (AR vs VR/Desktop) ===
  const isAR = (renderer.xr.getSession()?.environmentBlendMode !== 'opaque');
  mat.sizeAttenuation = !isAR; // AR: pixels (no attenuation), VR/Desktop: meters (attenuation)
  mat.size = isAR ? params.handPointSizePx : params.handPointSizeWorld;
  // ===============================================================

  mat.needsUpdate = true;

  const pts = new THREE.Points(geom, mat);
  pts.userData._clusterK = k;
  scene.add(pts);
  return pts;
}






// create Points after the joint nodes exist (right away is fine since we just added models)
hand0Points = makeHandPoints(hand0);
hand1Points = makeHandPoints(hand1);



// helper to update a hand Points from its joint world positions
const _tmp = new THREE.Vector3();


function updateHandPoints(hand, pts) {
  if (!pts || !hand.joints) return;
  const joints = Object.values(hand.joints);
  const nj = joints.length; if (!nj) return;

  // ensure geometry matches current density
  const k = Math.min(MAX_HAND_CLUSTER, Math.max(1, params.handClusterCount|0));
  const needed = nj * k * 3;
  let attrPos = pts.geometry.getAttribute('position');
  let attrCol = pts.geometry.getAttribute('color');
  if (!attrPos || attrPos.array.length !== needed) {
    const pos = new Float32Array(needed);
    const col = new Float32Array(needed);
    for (let i = 0; i < needed/3; i++) { col[i*3]=0.6; col[i*3+1]=0.8; col[i*3+2]=1.0; }
      pts.geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    pts.geometry.setAttribute('color',    new THREE.BufferAttribute(col, 3));
    attrPos = pts.geometry.getAttribute('position');
    attrCol = pts.geometry.getAttribute('color');
    pts.userData._clusterK = k;
  }

  const pos = attrPos.array;
  const col = attrCol.array;
  const r   = params.handClusterRadius;
  const bright = params.handBrightness;

  let m = 0;
  for (let j = 0; j < nj; j++) {
    const joint = joints[j];
    joint.getWorldPosition(_tmp);
    const baseX = _tmp.x, baseY = _tmp.y, baseZ = _tmp.z;

    for (let i = 0; i < k; i++) {
      const ox = HAND_OFFSETS[i*3]   * r;
      const oy = HAND_OFFSETS[i*3+1] * r;
      const oz = HAND_OFFSETS[i*3+2] * r;
      pos[m]   = baseX + ox;
      pos[m+1] = baseY + oy;
      pos[m+2] = baseZ + oz;

      // brightness applied here (clamped)
      const ci = (m/3)|0;
      col[ci*3]   = Math.min(1, 0.6 * bright);
      col[ci*3+1] = Math.min(1, 0.8 * bright);
      col[ci*3+2] = Math.min(1, 1.0 * bright);

      m += 3;
    }
  }

  attrPos.needsUpdate = true;
  attrCol.needsUpdate = true;
  pts.geometry.computeBoundingSphere();

  // === CHANGED: keep size in sync with GUI and AR/VR ===
  if (pts.material) {
    const isAR = (renderer.xr.getSession()?.environmentBlendMode !== 'opaque');
    pts.material.sizeAttenuation = !isAR; // AR: pixel size (no attenuation); VR/Desktop: world size (attenuation)
    pts.material.size = isAR ? params.handPointSizePx : params.handPointSizeWorld;
    pts.material.needsUpdate = true;
  }
  // =====================================================
}






// AR
document.body.appendChild( ARButton.createButton(renderer, {
  requiredFeatures: ['local-floor'],
  optionalFeatures: ['hand-tracking']   // <-- add this
}) );

// VR
document.body.appendChild( XRButton.createButton(renderer, {
  optionalFeatures: ['local-floor','bounded-floor','hand-tracking','layers']
}) );



function rebuildHandPoints() {
  // remove old
  if (hand0Points){ scene.remove(hand0Points); hand0Points.geometry.dispose(); hand0Points.material.dispose(); hand0Points=null; }
  if (hand1Points){ scene.remove(hand1Points); hand1Points.geometry.dispose(); hand1Points.material.dispose(); hand1Points=null; }
  // recreate if joints exist
  if (hand0.joints && Object.keys(hand0.joints).length) hand0Points = makeHandPoints(hand0);
  if (hand1.joints && Object.keys(hand1.joints).length) hand1Points = makeHandPoints(hand1);
}


function ensureHandPointsExist() {
  if (!hand0Points && hand0.joints && Object.keys(hand0.joints).length) {
    hand0Points = makeHandPoints(hand0);
  }
  if (!hand1Points && hand1.joints && Object.keys(hand1.joints).length) {
    hand1Points = makeHandPoints(hand1);
  }
}





  // Controllers: trigger cycles transitions

const controllerModelFactory = new XRControllerModelFactory();
const ctrl0 = renderer.xr.getController(0);
const ctrl1 = renderer.xr.getController(1);
scene.add(ctrl0, ctrl1);

const grip0 = renderer.xr.getControllerGrip(0);
const grip1 = renderer.xr.getControllerGrip(1);
grip0.add(controllerModelFactory.createControllerModel(grip0));
grip1.add(controllerModelFactory.createControllerModel(grip1));

scene.add(grip0, grip1);



  let triggerState = 0; // 0‚ÜíBuild, 1‚ÜíDissolve, 2‚ÜíReset, then repeat

  const cycleTransitions = ()=>{
    if (triggerState===0){ startBuild(); }
    else if (triggerState===1){ startDissolve(); }
    else { resetTransition(); }
    triggerState = (triggerState+1)%3;
  };

  ctrl0.addEventListener('selectstart', cycleTransitions);
  ctrl1.addEventListener('selectstart', cycleTransitions);




// XR session start/end: placement & material tweaks
  renderer.xr.addEventListener('sessionstart', () => {
  renderer.xr.setFoveation(0.0);              // 0..1  (0 = off, 1 = max)
  renderer.xr.setFramebufferScaleFactor(1.0); // 0.5..1 (lower = faster)

  controls.enabled = false;

  // Ensure hands exist and sizes mirror current session (AR vs VR)
  ensureHandPointsExist();
  syncComputedHandSizes();

  const s = renderer.xr.getSession();
  const blend = s?.environmentBlendMode || 'opaque';
  const isAR = (blend !== 'opaque');

  if (isAR) {
    // Transparent background over passthrough
    scene.background = null;
    renderer.setClearAlpha(0);

    // Place the cloud in front, slightly down, and scale smaller
    cloudGroup.position.set(0, params.xrYOffset, -params.xrDistance);
    cloudGroup.scale.setScalar(params.xrScale);

    // Points: screen-space sizing for crispness over camera feed
    cloudMaterial.sizeAttenuation = false;
    cloudMaterial.size = Math.max(params.pointSize, params.xrPointPixelSize);
    cloudMaterial.blending = THREE.NormalBlending;
    cloudMaterial.needsUpdate = true;

    // Hide VR floor/grid in AR
    floorGrid.visible = false;
  } else {
    // VR room: solid background, world-space size
    scene.background = new THREE.Color(0x000000);
    renderer.setClearAlpha(1);

    cloudGroup.position.set(0, 0, -1.2);
    cloudGroup.scale.setScalar(1);

    cloudMaterial.sizeAttenuation = true;
    cloudMaterial.size = params.pointSize;
    cloudMaterial.blending = THREE.AdditiveBlending;
    cloudMaterial.needsUpdate = true;

    floorGrid.visible = true;
  }

  // Keep external point-cloud materials synced (GLB point sets)
  externalGroups.forEach(g => {
    g.material.sizeAttenuation = !isAR; // AR: pixel size; VR: world-size attenuation
    g.material.size = isAR ? Math.max(params.pointSize, params.xrPointPixelSize) : params.pointSize;
    g.material.needsUpdate = true;
  });

  // XR-hand point clouds: screen-space in AR, world-space in VR
  if (hand0Points?.material) applyHandPointSizeTo(hand0Points.material);
  if (hand1Points?.material) applyHandPointSizeTo(hand1Points.material);

  // Hand steam particles:
  //  - make sure they exist
  //  - apply correct pixel/world sizing
  //  - enforce visibility from the preset
  if (!handSteamPoints || !handSteamGeom || !handSteamMat) {
    rebuildHandSteam(params.handSteamCount | 0);
  }
  applyHandSteamSize();
  if (handSteamPoints) handSteamPoints.visible = !!params.handSteamEnabled;

  // Attractor sphere visibility follows toggle
  if (typeof attractorSphere !== 'undefined' && attractorSphere) {
    attractorSphere.visible = !!params.handSteamAttractEnabled;
  }

  // Also keep external materials‚Äô fade uniforms up-to-date (already handled elsewhere, but safe)
  updateExternalPointMaterials();
});

  renderer.xr.addEventListener('sessionend', () => {
    controls.enabled = true;

    renderer.xr.setFoveation(0.0);
    renderer.xr.setFramebufferScaleFactor(1.0);

  // Back to desktop background
    scene.background = new THREE.Color(0x000000);
    renderer.setClearAlpha(1);

  // Restore desktop placement
    cloudGroup.position.set(0, 0, 0);
    cloudGroup.scale.setScalar(1);

    cloudMaterial.sizeAttenuation = true;
    cloudMaterial.size = params.pointSize;
    cloudMaterial.blending = THREE.NormalBlending;
    cloudMaterial.needsUpdate = true;

    floorGrid.visible = true;

  // External point clouds ‚Üí desktop/world sizing again
    externalGroups.forEach(g => {
      g.material.sizeAttenuation = true;
      g.material.size = params.pointSize;
      g.material.needsUpdate = true;
    });

  // Re-sync sizing mirrors for non-XR mode and apply to materials
    syncComputedHandSizes();

  // Restore desktop sizing for hand points
    if (hand0Points?.material) applyHandPointSizeTo(hand0Points.material);
    if (hand1Points?.material) applyHandPointSizeTo(hand1Points.material);

  // Restore desktop sizing for hand steam (and keep visibility)
    if (!handSteamPoints || !handSteamGeom || !handSteamMat) {
      rebuildHandSteam(params.handSteamCount | 0);
    }
    applyHandSteamSize();
    if (handSteamPoints) handSteamPoints.visible = !!params.handSteamEnabled;

  // Attractor visibility follows the toggle even outside XR
    if (typeof attractorSphere !== 'undefined' && attractorSphere) {
      attractorSphere.visible = !!params.handSteamAttractEnabled;
    }

    releaseSphere();

    updateExternalPointMaterials();
  });





    // ---------- Boot ----------
  bootstrap();


// --- NEW BLOCK: Drag & Drop + File input loader ---
  const gltfLoader = new GLTFLoader();

    // DRACO support (GLB/GLTF with KHR_draco_mesh_compression)
  const dracoLoader = new DRACOLoader();

    // Use Google's hosted decoder (fast + cached). Path must end with '/'
  dracoLoader.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/");
    dracoLoader.setWorkerLimit(2);          // optional, keeps CPU sane
    // (Optional) prefer WASM explicitly:
    // dracoLoader.setDecoderConfig({ type: "wasm" });

    gltfLoader.setDRACOLoader(dracoLoader);


    btnLoad?.addEventListener('click', () => fileInput.click(), { passive:true });
    fileInput?.addEventListener('change', async (e) => {
      const files = Array.from(e.target.files || []);
      for (const f of files) await loadModelFile(f);
        fileInput.value = "";
    }, { passive:true });

    window.addEventListener('dragover', (e)=>{
      e.preventDefault(); e.dataTransfer.dropEffect = "copy";
      dropHint?.classList.add('show');
    });
    window.addEventListener('dragleave', (e)=>{
      if (e.target === document || e.target === document.body) dropHint?.classList.remove('show');
    });
    window.addEventListener('drop', async (e)=>{
      e.preventDefault(); dropHint?.classList.remove('show');
      const files = Array.from(e.dataTransfer.files || []);
      for (const f of files) await loadModelFile(f);
    });

    async function loadModelFile(file) {
      const name = file.name.replace(/\.(glb|gltf)$/i,'');
      const isGLB = /\.glb$/i.test(file.name);
      const arrayBuf = await file.arrayBuffer();

      await new Promise((resolve, reject)=>{
        try {
          if (isGLB) {
            gltfLoader.parse(arrayBuf, '', (gltf)=>{
              const rec = gltfToPoints(gltf, { name, density: 1.0 });
              addExternalGroup(rec);
              resolve();
            }, reject);
          } else {
        // Attempt to parse embedded .gltf (external refs not supported here)
            const text = new TextDecoder().decode(new Uint8Array(arrayBuf));
            gltfLoader.parse(text, '', (gltf)=>{
              const rec = gltfToPoints(gltf, { name, density: 1.0 });
              addExternalGroup(rec);
              resolve();
            }, reject);
          }
        } catch (err) { reject(err); }
      }).catch(err=>{
        console.error("[viewer] Failed to load model:", err);
        overlay.classList.add("error");
        overlay.textContent = `Model load error: ${err?.message || err}`;
        setTimeout(()=> overlay.textContent = statusText, 2000);
      });
    }
// --- END NEW BLOCK ---


// --- NEW BLOCK: Models GUI panel (list each external point cloud) ---
    const gModels = gui.addFolder("Models");
let gModelsFolders = []; // per-group folders to destroy on rebuild
const modelGUIState = {
  transformMode: "translate" // or "rotate" / "scale"
};
gModels.add(modelGUIState, "transformMode", ["translate","rotate","scale"])
.name("Gizmo Mode")
.onChange(mode => tControls.setMode(mode));

function rebuildGroupsGUI() {
  // Cleanup old
  gModelsFolders.forEach(f => { try{ gModels.removeFolder?.(f); }catch{} });
  gModelsFolders = [];

  // Create a subfolder per group
  externalGroups.forEach(rec => {
    const f = gModels.addFolder(`[${rec.id}] ${rec.name}`);
    gModelsFolders.push(f);

    // visibility + selection
    const visCtrl = f.add(rec, "visible").name("Visible").onChange(v => { rec.group.visible = v; });
    f.add({ select: ()=> selectExternalGroup(rec.id) }, "select").name("Select");

    // density 0..1
    f.add(rec, "density", 0.01, 1.0, 0.01).name("Density").onChange(v => resampleGroupDensity(rec, v));

    // transforms
    const pos = { x: rec.group.position.x, y: rec.group.position.y, z: rec.group.position.z };
    const rot = { x: THREE.MathUtils.radToDeg(rec.group.rotation.x),
      y: THREE.MathUtils.radToDeg(rec.group.rotation.y),
      z: THREE.MathUtils.radToDeg(rec.group.rotation.z) };
      const scl = { s: rec.group.scale.x };

      f.add(pos, "x", -5, 5, 0.01).name("Pos X").onChange(v=> rec.group.position.x = v);
      f.add(pos, "y", -5, 5, 0.01).name("Pos Y").onChange(v=> rec.group.position.y = v);
      f.add(pos, "z", -5, 5, 0.01).name("Pos Z").onChange(v=> rec.group.position.z = v);

      f.add(rot, "x", -180, 180, 1).name("Rot X¬∞").onChange(v=> rec.group.rotation.x = THREE.MathUtils.degToRad(v));
      f.add(rot, "y", -180, 180, 1).name("Rot Y¬∞").onChange(v=> rec.group.rotation.y = THREE.MathUtils.degToRad(v));
      f.add(rot, "z", -180, 180, 1).name("Rot Z¬∞").onChange(v=> rec.group.rotation.z = THREE.MathUtils.degToRad(v));

      f.add(scl, "s", 0.01, 10, 0.01).name("Uniform Scale").onChange(v=> rec.group.scale.setScalar(v));

    // remove
      f.add({ remove: ()=>{
        if (selectedGroupId === rec.id) { tControls.detach(); selectedGroupId = null; }
        cloudGroup.remove(rec.group);
        rec.points.geometry.dispose(); rec.material.dispose();
        externalGroups = externalGroups.filter(g => g.id !== rec.id);
        rebuildGroupsGUI();
      }}, "remove").name("Remove");
    });
}
// --- END NEW BLOCK ---



    // Resize
window.addEventListener('resize', ()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  if (paused) renderer.render(scene,camera);
});

window.addEventListener("beforeunload", ()=>{ stopWS(); stopWebcam(); });
</script>

<!-- <script src="https://immersive-collective.org/projects/ic-badge/ic.js"></script> -->

</body>
</html>
