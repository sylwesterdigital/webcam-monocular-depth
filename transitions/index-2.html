<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Point Cloud ↔ Point Cloud Transitions (THREE.js)</title>
  <link rel="icon" href="data:,">
  <style>
    html,body { margin:0; height:100%; overflow:hidden; background:#000; }
    #overlay { position:fixed; top:12px; left:12px; color:#0f0; font:12px/1.4 monospace; background:rgba(0,0,0,.35); padding:8px 10px; border-radius:8px; pointer-events:none; }
    .hud { position:fixed; bottom:12px; left:12px; color:#9f9; font:12px/1.4 monospace; background:rgba(0,0,0,.35); padding:8px 10px; border-radius:8px; }
    a { color:#9f9; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.180.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.180.0/examples/jsm/",
        "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.18/dist/lil-gui.esm.min.js"
      }
    }
  </script>
</head>
<body>
  <div id="overlay">booting…</div>
  <div class="hud">
    Keys: [1..5] mode · [Space] trigger · [C] toggle cube/sphere target · [R] reshuffle · [P] pause · [F] fullscreen
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { GUI } from "lil-gui";

    // ---------- Scene ----------
    const overlay = document.getElementById("overlay");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 100);
    camera.position.set(0, 0, 3.2);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const light = new THREE.DirectionalLight(0xffffff, 0.6);
    light.position.set(1,1,1);
    scene.add(light, new THREE.AmbientLight(0xffffff, 0.2));

    // ---------- Parameters / GUI ----------
    const MODES = {
      "1 · Morph (ease)": "morph",
      "2 · Swirl Morph": "swirl",
      "3 · Bezier Flow": "bezier",
      "4 · Dissolve/Rebuild": "dissolve",
      "5 · Staggered Build": "stagger"
    };

    const params = {
      pointCount: 30000,
      pointSize: 0.01,
      mode: MODES["1 · Morph (ease)"],
      durationMs: 1400,
      swirlTurns: 1.0,
      bezierArc: 0.55,
      dissolveMs: 1200,
      colorLerp: true,
      target: "sphere", // target shape; source is whatever is currently shown
      jitter: 0.0,
      palette: "plasma",
      additive: true
    };

    const gui = new GUI();
    gui.add(params, "mode", MODES).name("Mode");
    gui.add(params, "pointCount", 2000, 80000, 1000).name("Points").onFinishChange(rebuildAll);
    gui.add(params, "pointSize", 0.003, 0.05, 0.001).name("Point Size").onChange(()=>{ ptsMat.size = params.pointSize; });
    gui.add(params, "durationMs", 300, 4000, 50).name("Duration");
    gui.add(params, "swirlTurns", 0, 3, 0.05).name("Swirl Turns");
    gui.add(params, "bezierArc", 0, 2, 0.01).name("Bezier Arc");
    gui.add(params, "dissolveMs", 300, 4000, 50).name("Dissolve/Rebuild ms");
    gui.add(params, "colorLerp").name("Color Crossfade");
    gui.add(params, "target", ["sphere","cube","torus","pyramid","icosphere","cylinder","point","flat-circle","flat-square"]).name("Target Shape").onFinishChange(triggerTransition);
    gui.add(params, "jitter", 0, 0.08, 0.001).name("Jitter");
    gui.add(params, "palette", ["ice","magma","plasma","viridis","rainbow"]).name("Palette").onFinishChange(recolor);
    gui.add(params, "additive").name("Additive Blend").onChange(toggleBlend);

    // ---------- Point cloud buffers ----------
    const geom = new THREE.BufferGeometry();
    const ptsMat = new THREE.PointsMaterial({ size: params.pointSize, vertexColors: true, depthWrite: false, transparent: true });
    toggleBlend();

    const points = new THREE.Points(geom, ptsMat);
    scene.add(points);

    // working arrays
    let A=null, B=null;        // source & target positions (Float32Array length 3N)
    let C=null;                // current interp positions (Float32Array length 3N)
    let colA=null, colB=null;  // colors for A and B
    let curCol=null;           // current colors
    let perm=null;             // pairing permutation
    let delays=null;           // for stagger mode
    let N=0;

    // track what shape is on-screen right now
    let currentShape = "cube"; // initialized to cube in rebuildAll()

    function ensure(Nnew){
      const need = (!C || C.length !== 3*Nnew);
      N = Nnew|0;
      if (need){
        A = new Float32Array(3*N);
        B = new Float32Array(3*N);
        C = new Float32Array(3*N);
        colA = new Float32Array(3*N);
        colB = new Float32Array(3*N);
        curCol = new Float32Array(3*N);
        perm = new Uint32Array(N);
        delays = new Float32Array(N);

        geom.setAttribute("position", new THREE.BufferAttribute(C, 3));
        geom.setAttribute("color", new THREE.BufferAttribute(curCol, 3));
      }
    }

    // ---------- Helpers ----------
    function halton(i, base){
      let f=1, r=0;
      while (i>0){ f/=base; r += f * (i%base); i = Math.floor(i/base); }
      return r;
    }

    function permutePairing(){
      for (let i=0;i<N;i++){
        const t = halton(i+1, 2);
        perm[i] = Math.floor(t * N) % N;
      }
      const used = new Uint8Array(N);
      for (let i=0;i<N;i++){
        let j = perm[i];
        while (used[j]) j = (j+1)%N;
        perm[i]=j; used[j]=1;
      }
      for (let i=0;i<N;i++){
        delays[i] = halton(i+1,3);
      }
    }

    // ---------- Base shapes ----------
    function buildSphere(dst){
      const r = 1.0;
      const g = (1 + Math.sqrt(5)) / 2;
      for (let i=0;i<N;i++){
        const t = (i+0.5)/N;
        const phi = 2*Math.PI * (i/g % 1);
        const z = 1 - 2*t;
        const rho = Math.sqrt(Math.max(0, 1 - z*z));
        const x = Math.cos(phi) * rho;
        const y = Math.sin(phi) * rho;
        dst[3*i]=r*x; dst[3*i+1]=r*y; dst[3*i+2]=r*z;
      }
    }

    function buildCube(dst){
      const s = 1.2;
      for (let i=0;i<N;i++){
        const f = (i*2654435761>>>0) % 6;
        let x = Math.random()*2-1, y = Math.random()*2-1, z = Math.random()*2-1;
        if (f===0){ x = -1; } else if (f===1){ x = 1; }
        else if (f===2){ y = -1; } else if (f===3){ y = 1; }
        else if (f===4){ z = -1; } else { z = 1; }
        if (f<2){ y = 2*Math.random()-1; z = 2*Math.random()-1; }
        else if (f<4){ x = 2*Math.random()-1; z = 2*Math.random()-1; }
        else { x = 2*Math.random()-1; y = 2*Math.random()-1; }
        dst[3*i]=s*x; dst[3*i+1]=s*y; dst[3*i+2]=s*z;
      }
    }

    // ---------- Extra shapes ----------
    function buildTorus(dst, R=1.0, r=0.42){
      for (let i=0;i<N;i++){
        const u=halton(i+1,2)*Math.PI*2;
        const v=halton(i+1,3)*Math.PI*2;
        const cu=Math.cos(u), su=Math.sin(u), cv=Math.cos(v), sv=Math.sin(v);
        const x=(R + r*cv)*cu, y=(R + r*cv)*su, z=r*sv;
        dst[3*i]=x; dst[3*i+1]=y; dst[3*i+2]=z;
      }
    }

    function buildPyramid(dst, base=1.6, h=1.8){
      const apex=[0,h/2,0], yb=-h/2, s=base/2;
      const b0=[-s,yb,-s], b1=[ s,yb,-s], b2=[ s,yb, s], b3=[-s,yb, s];
      for (let i=0;i<N;i++){
        const face=i%4; let v1=b0, v2=b1;
        if (face===1){ v1=b1; v2=b2; } else if (face===2){ v1=b2; v2=b3; } else if (face===3){ v1=b3; v2=b0; }
        let u=Math.random(), v=Math.random(); if (u+v>1){ u=1-u; v=1-v; }
        const x = apex[0]*(1-u-v)+v1[0]*u+v2[0]*v;
        const y = apex[1]*(1-u-v)+v1[1]*u+v2[1]*v;
        const z = apex[2]*(1-u-v)+v1[2]*u+v2[2]*v;
        dst[3*i]=x; dst[3*i+1]=y; dst[3*i+2]=z;
      }
    }

    function buildIcosphere(dst, radius=1){
      const t=(1+Math.sqrt(5))/2;
      const V=[
        [-1, t, 0],[ 1, t, 0],[-1,-t, 0],[ 1,-t, 0],
        [ 0,-1, t],[ 0, 1, t],[ 0,-1,-t],[ 0, 1,-t],
        [ t, 0,-1],[ t, 0, 1],[-t, 0,-1],[-t, 0, 1]
      ].map(v=>{ const L=Math.hypot(v[0],v[1],v[2])||1; return [v[0]/L,v[1]/L,v[2]/L]; });
      const F=[
        [0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],
        [1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],
        [3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],
        [4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]
      ];
      for (let i=0;i<N;i++){
        const f=F[i%F.length], a=V[f[0]], b=V[f[1]], c=V[f[2]];
        let u=Math.random(), v=Math.random(); if (u+v>1){ u=1-u; v=1-v; }
        const x=a[0]*(1-u-v)+b[0]*u+c[0]*v, y=a[1]*(1-u-v)+b[1]*u+c[1]*v, z=a[2]*(1-u-v)+b[2]*u+c[2]*v;
        const L=Math.hypot(x,y,z)||1; dst[3*i]=radius*x/L; dst[3*i+1]=radius*y/L; dst[3*i+2]=radius*z/L;
      }
    }

    function buildCylinder(dst, r=1.0, h=1.8){
      for (let i=0;i<N;i++){
        const section=i%5;
        if (section<3){
          const u=halton(i+1,2)*Math.PI*2; const y=(Math.random()-0.5)*h;
          dst[3*i]=r*Math.cos(u); dst[3*i+1]=y; dst[3*i+2]=r*Math.sin(u);
        } else {
          const top=(section===3), y=top?(+h/2):(-h/2);
          const rr=Math.sqrt(Math.random())*r, th=2*Math.PI*Math.random();
          dst[3*i]=rr*Math.cos(th); dst[3*i+1]=y; dst[3*i+2]=rr*Math.sin(th);
        }
      }
    }

    function buildPoint(dst){
      for (let i=0;i<N;i++){ dst[3*i]=0; dst[3*i+1]=0; dst[3*i+2]=0; }
    }

  function buildFlatCircle(dst, r=1.3){
    for (let i=0;i<N;i++){
      const rr=Math.sqrt(Math.random())*r, th=2*Math.PI*Math.random();
      dst[3*i]=rr*Math.cos(th); dst[3*i+1]=0; dst[3*i+2]=rr*Math.sin(th);
    }
  }

  function buildFlatSquare(dst, s=1.4){
    for (let i=0;i<N;i++){
      dst[3*i]=(Math.random()*2-1)*s; dst[3*i+1]=0; dst[3*i+2]=(Math.random()*2-1)*s;
    }
  }

  function buildShape(name, dst){
    if (name==="sphere") return buildSphere(dst);
    if (name==="cube") return buildCube(dst);
    if (name==="torus") return buildTorus(dst);
    if (name==="pyramid") return buildPyramid(dst);
    if (name==="icosphere") return buildIcosphere(dst);
    if (name==="cylinder") return buildCylinder(dst);
    if (name==="point") return buildPoint(dst);
    if (name==="flat-circle") return buildFlatCircle(dst);
    if (name==="flat-square") return buildFlatSquare(dst);
  }

    // ---------- Colors ----------
  function lerp(a,b,t){ return a+(b-a)*t; }
  function palette(name, t){
    if (name==="ice")     return [ lerp(0.6,0.9,t), lerp(0.8,1.0,t), lerp(1.0,1.0,t) ];
    if (name==="magma")   return [ Math.pow(t,0.6), Math.pow(t,2.2)*0.2, Math.pow(t,3.0)*0.05 ];
    if (name==="viridis") return [ 0.267+0.624*t, 0.004+0.676*t, 0.329+0.314*t ];
    if (name==="rainbow") return hsv2rgb(t, 0.85, 1.0);
    const a = 0.5 + 0.5*Math.sin(6.28318*(t*0.9));
    return [ 0.5+0.5*t, 0.05+0.9*a, 0.3+0.7*(1-t) ];
  }
  function hsv2rgb(h,s,v){
    const i = Math.floor(h*6); const f = h*6 - i; const p = v*(1-s); const q = v*(1-f*s); const t = v*(1-(1-f)*s);
    switch(i%6){
    case 0: return [v,t,p];
    case 1: return [q,v,p];
    case 2: return [p,v,t];
    case 3: return [p,q,v];
    case 4: return [t,p,v];
    case 5: return [v,p,q];
    }
  }

  function colorize(dst, pos){
    for (let i=0;i<N;i++){
      const x = pos[3*i], y = pos[3*i+1], z = pos[3*i+2];
      const t = THREE.MathUtils.clamp((Math.hypot(x,y,z)/1.4), 0, 1);
      const c = palette(params.palette, t);
      dst[3*i]=c[0]; dst[3*i+1]=c[1]; dst[3*i+2]=c[2];
    }
  }

  function recolor(){
    colorize(colA, A);
    colorize(colB, B);
    applyColor(0);
    geom.getAttribute('color').needsUpdate = true;
  }

  function toggleBlend(){
    ptsMat.blending = params.additive ? THREE.AdditiveBlending : THREE.NormalBlending;
    ptsMat.needsUpdate = true;
  }

    // ---------- Transition engine ----------
  let t0 = performance.now();
  let animMs = params.durationMs;
    let phase = "idle"; // "morphing" | "dissolving" | "rebuilding"
    let paused = false;
    let dissolveVel = null;

    function easeInOutCubic(t){ return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }
    function easeOutExpo(t){ return t===1?1:1 - Math.pow(2, -10*t); }

    function applyColor(tMix){
      if (!params.colorLerp){ curCol.set(colB); return; }
      const t = THREE.MathUtils.clamp(tMix, 0, 1);
      const a = 1 - t, b = t;
      for (let i=0;i<3*N;i++) curCol[i] = a*colA[i] + b*colB[i];
    }

  function jitterVec(i){
    const j = params.jitter;
    if (j<=0) return [0,0,0];
    const r1 = ( (i*16807)%2147483647 ) / 2147483647;
    const r2 = ( (i*48271)%2147483647 ) / 2147483647;
    const r3 = ( (i*69621)%2147483647 ) / 2147483647;
    return [ (r1-0.5)*2*j, (r2-0.5)*2*j, (r3-0.5)*2*j ];
  }

  function rotateY(vx,vy,vz, ang){
    const c=Math.cos(ang), s=Math.sin(ang);
    return [ c*vx + s*vz, vy, -s*vx + c*vz ];
  }

  function bezierPoint(ax,ay,az, bx,by,bz, t, arc){
    const mx = (ax+bx)/2, my=(ay+by)/2, mz=(az+bz)/2;
    let nx=-(by-ay), ny=(bx-ax), nz=0;
    const L = Math.hypot(nx,ny,nz)||1; nx/=L; ny/=L; nz/=L;
    const cx = mx + nx*arc, cy = my + ny*arc, cz = mz + nz*arc;
    const u = 1-t;
    return [
      u*u*ax + 2*u*t*cx + t*t*bx,
      u*u*ay + 2*u*t*cy + t*t*by,
      u*u*az + 2*u*t*cz + t*t*bz
    ];
  }

  function startMorph(){
    phase = "morphing";
    animMs = params.durationMs;
    t0 = performance.now();
  }

  function startDissolveRebuild(){
    if (!dissolveVel || dissolveVel.length !== 3*N) dissolveVel = new Float32Array(3*N);
    for (let i=0;i<N;i++){
      const ax = A[3*i], ay=A[3*i+1], az=A[3*i+2];
      const L = Math.hypot(ax,ay,az)||1;
      const dx = ax/L, dy=ay/L, dz=az/L;
      const s = 1.2 + Math.random()*0.8;
      dissolveVel[3*i]=dx*s; dissolveVel[3*i+1]=dy*s; dissolveVel[3*i+2]=dz*s;
    }
    phase = "dissolving";
    animMs = params.dissolveMs;
    t0 = performance.now();
  }

    // Source = the shape currently displayed (C). Destination = params.target.
  function triggerTransition(){
      // set A to current on-screen state, so next hop always starts from the latest shape
    A.set(C);
    buildShape(params.target, B);
    recolor();
    permutePairing();
    overlay.textContent = `N=${N} | ${currentShape} → ${params.target} | mode=${params.mode}`;
    if (params.mode==="dissolve") startDissolveRebuild();
    else startMorph();
  }

  function rebuildAll(){
    ensure(params.pointCount|0);
      // initial state: show cube, target sphere by default
    buildCube(A);
    buildSphere(B);
    currentShape = "cube";
    C.set(A);
    recolor();
    permutePairing();
    applyColor(0);
    geom.getAttribute('position').needsUpdate = true;
    geom.getAttribute('color').needsUpdate = true;
    geom.computeBoundingSphere();
    overlay.textContent = `N=${N} | ${currentShape} → ${params.target} | mode=${params.mode}`;
  }

    // ---------- Animation loop ----------
  let lastT = performance.now();

  function step(){
    const now = performance.now();
    const dt = (now - lastT)/1000; lastT = now;
    if (!paused){
      update(now);
      controls.update();
      renderer.render(scene, camera);
    }
    requestAnimationFrame(step);
  }

  function update(now){
    if (phase==="idle") return;

    const tRaw = THREE.MathUtils.clamp((now - t0) / animMs, 0, 1);
    const tEase = (params.mode==="stagger") ? tRaw : easeInOutCubic(tRaw);

    if (phase==="morphing"){
      const mode = params.mode;
      const turns = params.swirlTurns;
      const arc = params.bezierArc;

      if (mode==="stagger"){
        const span = params.durationMs;
        for (let i=0;i<N;i++){
            const start = delays[i]*0.7*span; // up to 70% delay
            const local = THREE.MathUtils.clamp((now - (t0+start)) / (span - start), 0, 1);
            const tt = easeOutExpo(local);
            const j = perm[i];
            const ax = A[3*i], ay=A[3*i+1], az=A[3*i+2];
            const bx = B[3*j], by=B[3*j+1], bz=B[3*j+2];
            const [jx,jy,jz] = jitterVec(i);
            C[3*i]   = ax*(1-tt) + (bx+jx)*tt;
            C[3*i+1] = ay*(1-tt) + (by+jy)*tt;
            C[3*i+2] = az*(1-tt) + (bz+jz)*tt;
          }
          applyColor(tRaw);
        }
        else if (mode==="morph"){
          for (let i=0;i<N;i++){
            const j = perm[i];
            const ax = A[3*i], ay=A[3*i+1], az=A[3*i+2];
            const bx = B[3*j], by=B[3*j+1], bz=B[3*j+2];
            const [jx,jy,jz] = jitterVec(i);
            const t = tEase;
            C[3*i]   = ax*(1-t) + (bx+jx)*t;
            C[3*i+1] = ay*(1-t) + (by+jy)*t;
            C[3*i+2] = az*(1-t) + (bz+jz)*t;
          }
          applyColor(tEase);
        }
        else if (mode==="swirl"){
          const theta = (1 - tEase) * turns * Math.PI*2;
          for (let i=0;i<N;i++){
            const j = perm[i];
            let ax = A[3*i], ay=A[3*i+1], az=A[3*i+2];
            [ax,ay,az] = rotateY(ax,ay,az, theta);
            const bx = B[3*j], by=B[3*j+1], bz=B[3*j+2];
            const [jx,jy,jz] = jitterVec(i);
            C[3*i]   = ax*(1-tEase) + (bx+jx)*tEase;
            C[3*i+1] = ay*(1-tEase) + (by+jy)*tEase;
            C[3*i+2] = az*(1-tEase) + (bz+jz)*tEase;
          }
          applyColor(tEase);
        }
        else if (mode==="bezier"){
          for (let i=0;i<N;i++){
            const j = perm[i];
            const ax = A[3*i], ay=A[3*i+1], az=A[3*i+2];
            const bx = B[3*j], by=B[3*j+1], bz=B[3*j+2];
            const [px,py,pz] = bezierPoint(ax,ay,az, bx,by,bz, tEase, arc);
            const [jx,jy,jz] = jitterVec(i);
            C[3*i]   = px + jx*(1-tEase);
            C[3*i+1] = py + jy*(1-tEase);
            C[3*i+2] = pz + jz*(1-tEase);
          }
          applyColor(tEase);
        }

        geom.getAttribute('position').needsUpdate = true;
        geom.getAttribute('color').needsUpdate = true;
        if (tRaw>=1){
          // update "current shape" to the shape just reached
          currentShape = params.target;
          // swap A/B color buffers for next run as before
          const tmpP = A; A = B; B = tmpP;
          const tmpC = colA; colA = colB; colB = tmpC;
          phase="idle";
          overlay.textContent = `N=${N} | at ${currentShape} · next → ${params.target}`;
        }
      }
      else if (phase==="dissolving"){
        const tt = tRaw;
        const fade = 1 - tt;
        ptsMat.opacity = fade;
        for (let i=0;i<N;i++){
          C[3*i]   = A[3*i]   + dissolveVel[3*i]  * tt*1.0;
          C[3*i+1] = A[3*i+1] + dissolveVel[3*i+1]* tt*1.0;
          C[3*i+2] = A[3*i+2] + dissolveVel[3*i+2]* tt*1.0;
        }
        geom.getAttribute('position').needsUpdate = true;

        if (tt>=1){
          for (let i=0;i<N;i++){
            C[3*i]   = (Math.random()*2-1)*3.5;
            C[3*i+1] = (Math.random()*2-1)*3.5;
            C[3*i+2] = (Math.random()*2-1)*3.5;
          }
          ptsMat.opacity = 0.0;
          phase = "rebuilding";
          animMs = params.dissolveMs;
          t0 = performance.now();
        }
      }
      else if (phase==="rebuilding"){
        const tt = easeInOutCubic((now - t0)/animMs);
        ptsMat.opacity = tt;
        for (let i=0;i<N;i++){
          const j = perm[i];
          const bx = B[3*j], by=B[3*j+1], bz=B[3*j+2];
          const [jx,jy,jz] = jitterVec(i);
          C[3*i]   = C[3*i]  *(1-tt) + (bx+jx)*tt;
          C[3*i+1] = C[3*i+1]*(1-tt) + (by+jy)*tt;
          C[3*i+2] = C[3*i+2]*(1-tt) + (bz+jz)*tt;
        }
        applyColor(tt);
        geom.getAttribute('position').needsUpdate = true;
        geom.getAttribute('color').needsUpdate = true;

        if ( (now-t0) >= animMs ){
          currentShape = params.target; // landed on the new shape
          const tmpP = A; A = B; B = tmpP;
          const tmpC = colA; colA = colB; colB = tmpC;
          phase = "idle";
          ptsMat.opacity = 1.0;
          overlay.textContent = `N=${N} | at ${currentShape} · next → ${params.target}`;
        }
      }
    }

    // ---------- Input ----------
    window.addEventListener("keydown",(e)=>{
      const k=e.key.toLowerCase();
      if (k===" "){ triggerTransition(); }
      else if (k==="c"){
        params.target = (params.target==="sphere"?"cube":"sphere");
        triggerTransition();
      }
      else if (k==="r"){ permutePairing(); triggerTransition(); }
      else if (k==="p"){ paused = !paused; }
      else if (k==="f"){ toggleFullscreen(); }
      else if (k==="1"){ params.mode = MODES["1 · Morph (ease)"]; startMorph(); }
      else if (k==="2"){ params.mode = MODES["2 · Swirl Morph"]; startMorph(); }
      else if (k==="3"){ params.mode = MODES["3 · Bezier Flow"]; startMorph(); }
      else if (k==="4"){ params.mode = MODES["4 · Dissolve/Rebuild"]; startDissolveRebuild(); }
      else if (k==="5"){ params.mode = MODES["5 · Staggered Build"]; startMorph(); }
      overlay.textContent = `N=${N} | ${currentShape} → ${params.target} | mode=${params.mode}`;
    });

    async function toggleFullscreen(){
      try{
        if (!document.fullscreenElement) await document.body.requestFullscreen({navigationUI:"hide"}).catch(()=>document.body.requestFullscreen());
        else await document.exitFullscreen();
      }catch(e){}
    }

    // ---------- Boot ----------
    rebuildAll();
    // optional: kick off first transition to whatever GUI target is
    // triggerTransition();
    step();

    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      if (paused) renderer.render(scene,camera);
    });
  </script>
</body>
</html>
