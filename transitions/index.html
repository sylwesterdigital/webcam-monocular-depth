<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Point Cloud ↔ Point Cloud Transitions (THREE.js + WebXR)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <link rel="icon" href="data:,">
  <style>
    html,body { margin:0; height:100%; overflow:hidden; background:#000; }
    #overlay { position:fixed; top:12px; left:12px; color:#0f0; font:12px/1.4 monospace; background:rgba(0,0,0,.35); padding:8px 10px; border-radius:8px; pointer-events:none; }
    .hud { position:fixed; bottom:12px; left:12px; color:#9f9; font:12px/1.4 monospace; background:rgba(0,0,0,.35); padding:8px 10px; border-radius:8px; }
    a { color:#9f9; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.180.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.180.0/examples/jsm/",
        "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.18/dist/lil-gui.esm.min.js"
      }
    }
  </script>
</head>
<body>
  <div id="overlay">booting…</div>
  <div class="hud">
    Keys: [1..5] mode · [Space] trigger · [C] toggle cube/sphere · [R] reshuffle · [P] pause · [F] fullscreen · [X] recenter AR
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { GUI } from "lil-gui";
    import { XRButton } from "three/addons/webxr/XRButton.js";
    import { ARButton } from "three/addons/webxr/ARButton.js";
    import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";

    // ---------- Scene ----------
    const overlay = document.getElementById("overlay");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 100);
    camera.position.set(0, 0, 3.2);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    renderer.xr.enabled = true;
    // Force floor-referenced origin in XR
    renderer.xr.setReferenceSpaceType('local-floor');
    renderer.xr.setFoveation(0);

    document.body.appendChild(renderer.domElement);

    // Orbit controls + smart auto-orbit
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = false;
    controls.autoRotateSpeed = 0.6;
    controls.target.set(0,0,0);

    let autoOrbitOn = true;
    let autoOrbitRamp = 0;
    const IDLE_MS = 1800, RAMP_IN_MS = 1200, RAMP_OUT_MS = 200;
    let lastUserInteractT = performance.now();

    function markUserInteraction(){ lastUserInteractT = performance.now(); autoOrbitOn = false; }
    controls.addEventListener('start', markUserInteraction);
    renderer.domElement.addEventListener('pointerdown', markUserInteraction);
    renderer.domElement.addEventListener('wheel', markUserInteraction, { passive:true });
    window.addEventListener('keydown', markUserInteraction);

    // Lights
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.75);
    dirLight.position.set(2,4,2);
    scene.add(dirLight, new THREE.AmbientLight(0xffffff, 0.25));

    // ---------- WORLD ANCHORS ----------
    const grid = new THREE.GridHelper(20, 40, 0x444444, 0x222222);
    grid.position.y = 0;     // y=0 is floor in 'local-floor'
    // scene.add(grid);

    const floorMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0, roughness: 1 });
    const floorGeo = new THREE.PlaneGeometry(20, 20);
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI/2;
    floor.position.y = -2; // avoid z-fight with grid
    // scene.add(floor);

    const markers = new THREE.Group();
    const mkMat1 = new THREE.MeshStandardMaterial({ color: 0x3399ff, emissive: 0x113355, roughness: 0.6, metalness: 0.1 });
    const mkMat2 = new THREE.MeshStandardMaterial({ color: 0xff6666, emissive: 0x331111, roughness: 0.6, metalness: 0.1 });
    const mkMat3 = new THREE.MeshStandardMaterial({ color: 0x66ff88, emissive: 0x113322, roughness: 0.6, metalness: 0.1 });
    const mkCube = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8), mkMat1); mkCube.position.set(3, 1.0, -4);
    const mkSphere = new THREE.Mesh(new THREE.SphereGeometry(0.6, 32, 16), mkMat2); mkSphere.position.set(-3, 1.2, -6);
    const mkCone = new THREE.Mesh(new THREE.ConeGeometry(0.6, 1.2, 28), mkMat3); mkCone.position.set(0, 1.4, -8);
    markers.add(mkCube, mkSphere, mkCone);
    scene.add(markers);

    // ---------- Parameters / GUI ----------
    const MODES = {
      "1 · Morph (ease)": "morph",
      "2 · Swirl Morph": "swirl",
      "3 · Bezier Flow": "bezier",
      "4 · Dissolve/Rebuild": "dissolve",
      "5 · Staggered Build": "stagger"
    };
    const SHAPES = ["sphere","cube","torus","pyramid","icosphere","cylinder","point","flat-circle","flat-square"];

    const params = {
      pointCount: 30000,
      pointSize: 0.01,
      mode: MODES["1 · Morph (ease)"],
      durationMs: 1400,
      swirlTurns: 1.0,
      bezierArc: 0.55,
      dissolveMs: 1200,
      colorLerp: true,
      target: "sphere",
      jitter: 0.0,
      palette: "plasma",
      additive: true,
      // AR placement knobs
      arDistance: 0.6,   // meters in front of eyes
      arScale: 0.2,      // 5× smaller
      arYOffset: 0.0     // adjust up/down if needed (meters)
    };

    const gui = new GUI();
    gui.add(params, "mode", MODES).name("Mode");
    gui.add(params, "pointCount", 2000, 80000, 1000).name("Points").onFinishChange(rebuildAll);
    gui.add(params, "pointSize", 0.003, 0.05, 0.001).name("Point Size").onChange(()=>{ ptsMat.size = params.pointSize; });
    gui.add(params, "durationMs", 300, 4000, 50).name("Duration");
    gui.add(params, "swirlTurns", 0, 3, 0.05).name("Swirl Turns");
    gui.add(params, "bezierArc", 0, 2, 0.01).name("Bezier Arc");
    gui.add(params, "dissolveMs", 300, 4000, 50).name("Dissolve/Rebuild ms");
    gui.add(params, "colorLerp").name("Color Crossfade");
    gui.add(params, "target", SHAPES).name("Target Shape").onFinishChange(triggerTransition);
    gui.add(params, "jitter", 0, 0.08, 0.001).name("Jitter");
    gui.add(params, "palette", ["ice","magma","plasma","viridis","rainbow"]).name("Palette").onFinishChange(recolor);
    gui.add(params, "additive").name("Additive Blend").onChange(toggleBlend);
    const gXR = gui.addFolder("AR Placement");
    gXR.add(params, "arDistance", 0.2, 1.5, 0.01).name("AR Distance (m)");
    gXR.add(params, "arScale", 0.05, 0.6, 0.01).name("AR Scale");
    gXR.add(params, "arYOffset", -0.5, 0.5, 0.01).name("AR Y Offset");
    gXR.add({ recenterAR }, "recenterAR").name("Recenter Now");
    gXR.open();

    // ---------- Point cloud (movable group for XR) ----------
    const cloudGroup = new THREE.Group();
    scene.add(cloudGroup);

    const geom = new THREE.BufferGeometry();
    const ptsMat = new THREE.PointsMaterial({
      size: params.pointSize,
      vertexColors: true,
      depthWrite: false,
      transparent: true,
      sizeAttenuation: true
    });
    toggleBlend();

    const points = new THREE.Points(geom, ptsMat);
    cloudGroup.add(points);

    let A=null, B=null, C=null;
    let colA=null, colB=null, curCol=null;
    let perm=null, delays=null;
    let N=0;

    let currentShape = "cube";

    function ensure(Nnew){
      const need = (!C || C.length !== 3*Nnew);
      N = Nnew|0;
      if (need){
        A = new Float32Array(3*N);
        B = new Float32Array(3*N);
        C = new Float32Array(3*N);
        colA = new Float32Array(3*N);
        colB = new Float32Array(3*N);
        curCol = new Float32Array(3*N);
        perm = new Uint32Array(N);
        delays = new Float32Array(N);
        geom.setAttribute("position", new THREE.BufferAttribute(C, 3));
        geom.setAttribute("color", new THREE.BufferAttribute(curCol, 3));
      }
    }

    // ---------- Utilities ----------
    function halton(i, base){ let f=1, r=0; while (i>0){ f/=base; r+=f*(i%base); i=Math.floor(i/base); } return r; }
    function permutePairing(){
      for (let i=0;i<N;i++){ const t=halton(i+1,2); perm[i]=Math.floor(t*N)%N; }
        const used=new Uint8Array(N);
      for (let i=0;i<N;i++){ let j=perm[i]; while (used[j]) j=(j+1)%N; perm[i]=j; used[j]=1; }
        for (let i=0;i<N;i++){ delays[i]=halton(i+1,3); }
      }

    // ---------- Shapes ----------
    function buildSphere(dst){ const r=1.0, g=(1+Math.sqrt(5))/2;
    for (let i=0;i<N;i++){ const t=(i+0.5)/N, phi=2*Math.PI*((i/g)%1), z=1-2*t, rho=Math.sqrt(Math.max(0,1-z*z));
      dst[3*i]=r*Math.cos(phi)*rho; dst[3*i+1]=r*Math.sin(phi)*rho; dst[3*i+2]=r*z; } }
    function buildCube(dst){ const s=1.2;
    for (let i=0;i<N;i++){ const f=(i*2654435761>>>0)%6; let x=Math.random()*2-1,y=Math.random()*2-1,z=Math.random()*2-1;
      if (f===0){x=-1;} else if (f===1){x=1;} else if (f===2){y=-1;} else if (f===3){y=1;} else if (f===4){z=-1;} else {z=1;}
    if (f<2){ y=2*Math.random()-1; z=2*Math.random()-1; } else if (f<4){ x=2*Math.random()-1; z=2*Math.random()-1; } else { x=2*Math.random()-1; y=2*Math.random()-1; }
    dst[3*i]=s*x; dst[3*i+1]=s*y; dst[3*i+2]=s*z; } }
    function buildTorus(dst,R=1.0,r=0.42){
      for (let i=0;i<N;i++){
        const u=halton(i+1,2)*Math.PI*2, v=halton(i+1,3)*Math.PI*2;
        const cu=Math.cos(u),su=Math.sin(u),cv=Math.cos(v),sv=Math.sin(v);
        const x=(R+r*cv)*cu, y=(R+r*cv)*su, z=r*sv;
        dst[3*i]=x; dst[3*i+1]=y; dst[3*i+2]=z;
      }
    }
    function buildPyramid(dst,base=1.6,h=1.8){
      const apex=[0,h/2,0], yb=-h/2, s=base/2, b0=[-s,yb,-s],b1=[s,yb,-s],b2=[s,yb,s],b3=[-s,yb,s];
      for (let i=0;i<N;i++){
        const face=i%4; let v1=b0,v2=b1; if(face===1){v1=b1;v2=b2;} else if(face===2){v1=b2;v2=b3;} else if(face===3){v1=b3;v2=b0;}
        let u=Math.random(),v=Math.random(); if(u+v>1){u=1-u; v=1-v;}
        const x=apex[0]*(1-u-v)+v1[0]*u+v2[0]*v, y=apex[1]*(1-u-v)+v1[1]*u+v2[1]*v, z=apex[2]*(1-u-v)+v1[2]*u+v2[2]*v;
        dst[3*i]=x; dst[3*i+1]=y; dst[3*i+2]=z;
      }
    }
    function buildIcosphere(dst,radius=1){
      const t=(1+Math.sqrt(5))/2;
      const V=[[-1,t,0],[1,t,0],[-1,-t,0],[1,-t,0],[0,-1,t],[0,1,t],[0,-1,-t],[0,1,-t],[t,0,-1],[t,0,1],[-t,0,-1],[-t,0,1]]
      .map(v=>{const L=Math.hypot(v[0],v[1],v[2])||1; return [v[0]/L,v[1]/L,v[2]/L];});
      const F=[[0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],[1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],[3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],[4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]];
      for (let i=0;i<N;i++){
        const f=F[i%F.length], a=V[f[0]], b=V[f[1]], c=V[f[2]];
        let u=Math.random(), v=Math.random(); if(u+v>1){u=1-u; v=1-v;}
        const x=a[0]*(1-u-v)+b[0]*u+c[0]*v, y=a[1]*(1-u-v)+b[1]*u+c[1]*v, z=a[2]*(1-u-v)+b[2]*u+c[2]*v;
        const L=Math.hypot(x,y,z)||1;
        dst[3*i]=radius*x/L; dst[3*i+1]=radius*y/L; dst[3*i+2]=radius*z/L;
      }
    }
    function buildCylinder(dst,r=1.0,h=1.8){
      for (let i=0;i<N;i++){
        const section=i%5;
        if(section<3){
          const u=halton(i+1,2)*Math.PI*2, y=(Math.random()-0.5)*h;
          dst[3*i]=r*Math.cos(u); dst[3*i+1]=y; dst[3*i+2]=r*Math.sin(u);
        } else {
          const top=(section===3), y=top?(+h/2):(-h/2);
          const rr=Math.sqrt(Math.random())*r, th=2*Math.PI*Math.random();
          dst[3*i]=rr*Math.cos(th); dst[3*i+1]=y; dst[3*i+2]=rr*Math.sin(th);
        }
      }
    }
    function buildPoint(dst){ for (let i=0;i<N;i++){ dst[3*i]=0; dst[3*i+1]=0; dst[3*i+2]=0; } }
    function buildFlatCircle(dst,r=1.3){
      for (let i=0;i<N;i++){
        const rr=Math.sqrt(Math.random())*r, th=2*Math.PI*Math.random();
        dst[3*i]=rr*Math.cos(th); dst[3*i+1]=0; dst[3*i+2]=rr*Math.sin(th);
      }
    }
    function buildFlatSquare(dst,s=1.4){
      for (let i=0;i<N;i++){
        dst[3*i]=(Math.random()*2-1)*s; dst[3*i+1]=0; dst[3*i+2]=(Math.random()*2-1)*s;
      }
    }
    function buildShape(name,dst){
      if (name==="sphere") return buildSphere(dst);
      if (name==="cube") return buildCube(dst);
      if (name==="torus") return buildTorus(dst);
      if (name==="pyramid") return buildPyramid(dst);
      if (name==="icosphere") return buildIcosphere(dst);
      if (name==="cylinder") return buildCylinder(dst);
      if (name==="point") return buildPoint(dst);
      if (name==="flat-circle") return buildFlatCircle(dst);
      if (name==="flat-square") return buildFlatSquare(dst);
    }

    // ---------- Colors ----------
    function lerp(a,b,t){ return a+(b-a)*t; }
    function palette(name, t){
      if (name==="ice")     return [ lerp(0.6,0.9,t), lerp(0.8,1.0,t), lerp(1.0,1.0,t) ];
      if (name==="magma")   return [ Math.pow(t,0.6), Math.pow(t,2.2)*0.2, Math.pow(t,3.0)*0.05 ];
      if (name==="viridis") return [ 0.267+0.624*t, 0.004+0.676*t, 0.329+0.314*t ];
      if (name==="rainbow") return hsv2rgb(t, 0.85, 1.0);
      const a = 0.5 + 0.5*Math.sin(6.28318*(t*0.9));
      return [ 0.5+0.5*t, 0.05+0.9*a, 0.3+0.7*(1-t) ];
    }
    function hsv2rgb(h,s,v){
      const i = Math.floor(h*6), f=h*6-i, p=v*(1-s), q=v*(1-f*s), t=v*(1-(1-f)*s);
      switch(i%6){ case 0:return [v,t,p]; case 1:return [q,v,p]; case 2:return [p,v,t]; case 3:return [p,q,v]; case 4:return [t,p,v]; default:return [v,p,q]; }
    }
    function colorize(dst, pos){
      for (let i=0;i<N;i++){
        const x = pos[3*i], y = pos[3*i+1], z = pos[3*i+2];
        const t = THREE.MathUtils.clamp((Math.hypot(x,y,z)/1.4), 0, 1);
        const c = palette(params.palette, t);
        dst[3*i]=c[0]; dst[3*i+1]=c[1]; dst[3*i+2]=c[2];
      }
    }
    function recolor(){ colorize(colA, A); colorize(colB, B); applyColor(0); geom.getAttribute('color').needsUpdate = true; }
    function toggleBlend(){ ptsMat.blending = params.additive ? THREE.AdditiveBlending : THREE.NormalBlending; ptsMat.needsUpdate = true; }

    // ---------- Transition engine ----------
    let t0 = performance.now();
    let animMs = params.durationMs;
    let phase = "idle";
    let paused = false;
    let dissolveVel = null;

    function easeInOutCubic(t){ return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }
    function easeOutExpo(t){ return t===1?1:1 - Math.pow(2, -10*t); }

    function applyColor(tMix){
      if (!params.colorLerp){ curCol.set(colB); return; }
      const t = THREE.MathUtils.clamp(tMix, 0, 1);
      const a = 1 - t, b = t;
      for (let i=0;i<3*N;i++) curCol[i] = a*colA[i] + b*colB[i];
    }
  function jitterVec(i){
    const j = params.jitter;
    if (j<=0) return [0,0,0];
    const r1=((i*16807)%2147483647)/2147483647, r2=((i*48271)%2147483647)/2147483647, r3=((i*69621)%2147483647)/2147483647;
    return [(r1-0.5)*2*j,(r2-0.5)*2*j,(r3-0.5)*2*j];
  }
  function rotateY(vx,vy,vz, ang){ const c=Math.cos(ang), s=Math.sin(ang); return [ c*vx + s*vz, vy, -s*vx + c*vz ]; }
  function bezierPoint(ax,ay,az, bx,by,bz, t, arc){
    const mx=(ax+bx)/2, my=(ay+by)/2, mz=(az+bz)/2; let nx=-(by-ay), ny=(bx-ax), nz=0; const L=Math.hypot(nx,ny,nz)||1; nx/=L; ny/=L; nz/=L;
    const cx=mx+nx*arc, cy=my+ny*arc, cz=mz+nz*arc; const u=1-t;
    return [ u*u*ax + 2*u*t*cx + t*t*bx, u*u*ay + 2*u*t*cy + t*t*by, u*u*az + 2*u*t*cz + t*t*bz ];
  }

  function startMorph(){ phase="morphing"; animMs=params.durationMs; t0=performance.now(); }
  function startDissolveRebuild(){
    if (!dissolveVel || dissolveVel.length!==3*N) dissolveVel=new Float32Array(3*N);
    for (let i=0;i<N;i++){
      const ax=A[3*i], ay=A[3*i+1], az=A[3*i+2], L=Math.hypot(ax,ay,az)||1, s=1.2+Math.random()*0.8;
      dissolveVel[3*i]=ax/L*s; dissolveVel[3*i+1]=ay/L*s; dissolveVel[3*i+2]=az/L*s;
    }
    phase="dissolving"; animMs=params.dissolveMs; t0=performance.now();
  }

  function triggerTransition(){
    A.set(C);
    buildShape(params.target, B);
    recolor();
    permutePairing();
    overlay.textContent = `N=${N} | ${currentShape} → ${params.target} | mode=${params.mode}`;
    if (params.mode==="dissolve") startDissolveRebuild(); else startMorph();
  }

  function rebuildAll(){
    ensure(params.pointCount|0);
    buildCube(A);
    buildSphere(B);
    currentShape = "cube";
    C.set(A);
    recolor();
    permutePairing();
    applyColor(0);
    geom.getAttribute('position').needsUpdate = true;
    geom.getAttribute('color').needsUpdate = true;
    geom.computeBoundingSphere();
    overlay.textContent = `N=${N} | ${currentShape} → ${params.target} | mode=${params.mode}`;
  }

    // ---------- Animation / Auto-orbit ----------
  renderer.setAnimationLoop(animate);

    // Place-once flag for AR
  let needsARPlace = false;
  function placeNearEyesOnce(){
      // ArrayCamera in XR contains two sub-cameras; world position is valid
    const xrCam = renderer.xr.getCamera(camera);
    const eyePos = new THREE.Vector3();
    xrCam.getWorldPosition(eyePos);

      // Forward direction (negative Z in camera space)
    const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(xrCam.quaternion).normalize();

      // Position: in front of eyes by arDistance, with optional Y offset
    const pos = eyePos.clone().addScaledVector(fwd, params.arDistance);
    pos.y += params.arYOffset;

    cloudGroup.position.copy(pos);

      // Face the user
    const lookAt = eyePos.clone();
    cloudGroup.lookAt(lookAt);

      // Scale smaller
    cloudGroup.scale.setScalar(params.arScale);

      // Points: screen-space in AR for clarity
    ptsMat.sizeAttenuation = false;
    ptsMat.size = Math.max(params.pointSize, 0.02);
    ptsMat.blending = THREE.NormalBlending;
    ptsMat.needsUpdate = true;

    needsARPlace = false;
  }

  function recenterAR(){
    if (!renderer.xr.isPresenting) return;
      needsARPlace = true; // will place on next frame using current head pose
    }

    function animate(time){
      const now = time ?? performance.now();

      // AR: do one-time placement based on current head pose
      if (renderer.xr.isPresenting && needsARPlace){
        placeNearEyesOnce();
      }

      if (!renderer.xr.isPresenting){
        const idle = now - lastUserInteractT;
        const wantAuto = idle > IDLE_MS;
        if (wantAuto) autoOrbitOn = true;

        const target = autoOrbitOn ? 1 : 0;
        const last = animate._lastNow ?? now;
        const dt = Math.max(0, now - last);
        const rate = target > autoOrbitRamp ? 1/RAMP_IN_MS : 1/RAMP_OUT_MS;
        autoOrbitRamp = THREE.MathUtils.clamp(autoOrbitRamp + (target>autoOrbitRamp? +rate*dt : -rate*dt), 0, 1);

        controls.autoRotate = autoOrbitRamp > 0.001;
        controls.autoRotateSpeed = 0.6 * autoOrbitRamp;
      } else {
        controls.autoRotate = false;
        autoOrbitOn = false;
        autoOrbitRamp = 0;
      }

      if (!paused){
        update(now);
        controls.update();
        renderer.render(scene, camera);
      }
      animate._lastNow = now;
    }

    function update(now){
      if (phase==="idle") return;

      const tRaw = THREE.MathUtils.clamp((now - t0) / animMs, 0, 1);
      const tEase = (params.mode==="stagger") ? tRaw : easeInOutCubic(tRaw);

      if (phase==="morphing"){
        const mode=params.mode, turns=params.swirlTurns, arc=params.bezierArc;

        if (mode==="stagger"){
          const span=params.durationMs;
          for (let i=0;i<N;i++){
            const start=delays[i]*0.7*span;
            const local=THREE.MathUtils.clamp((now-(t0+start))/(span-start),0,1);
            const tt=easeOutExpo(local); const j=perm[i];
            const ax=A[3*i], ay=A[3*i+1], az=A[3*i+2]; const bx=B[3*j], by=B[3*j+1], bz=B[3*j+2];
            const [jx,jy,jz]=jitterVec(i);
            C[3*i]=ax*(1-tt)+(bx+jx)*tt; C[3*i+1]=ay*(1-tt)+(by+jy)*tt; C[3*i+2]=az*(1-tt)+(bz+jz)*tt;
          }
          applyColor(tRaw);
        } else if (mode==="morph"){
          for (let i=0;i<N;i++){
            const j=perm[i]; const ax=A[3*i], ay=A[3*i+1], az=A[3*i+2]; const bx=B[3*j], by=B[3*j+1], bz=B[3*j+2];
            const [jx,jy,jz]=jitterVec(i); const t=tEase;
            C[3*i]=ax*(1-t)+(bx+jx)*t; C[3*i+1]=ay*(1-t)+(by+jy)*t; C[3*i+2]=az*(1-t)+(bz+jz)*t;
          }
          applyColor(tEase);
        } else if (mode==="swirl"){
          const theta=(1-tEase)*turns*Math.PI*2;
          for (let i=0;i<N;i++){
            const j=perm[i]; let ax=A[3*i], ay=A[3*i+1], az=A[3*i+2];
            [ax,ay,az]=rotateY(ax,ay,az,theta);
            const bx=B[3*j], by=B[3*j+1], bz=B[3*j+2]; const [jx,jy,jz]=jitterVec(i);
            C[3*i]=ax*(1-tEase)+(bx+jx)*tEase; C[3*i+1]=ay*(1-tEase)+(by+jy)*tEase; C[3*i+2]=az*(1-tEase)+(bz+jz)*tEase;
          }
          applyColor(tEase);
        } else if (mode==="bezier"){
          for (let i=0;i<N;i++){
            const j=perm[i]; const ax=A[3*i], ay=A[3*i+1], az=A[3*i+2]; const bx=B[3*j], by=B[3*j+1], bz=B[3*j+2];
            const [px,py,pz]=bezierPoint(ax,ay,az,bx,by,bz,tEase,arc); const [jx,jy,jz]=jitterVec(i);
            C[3*i]=px+jx*(1-tEase); C[3*i+1]=py+jy*(1-tEase); C[3*i+2]=pz+jz*(1-tEase);
          }
          applyColor(tEase);
        }

        geom.getAttribute('position').needsUpdate = true;
        geom.getAttribute('color').needsUpdate = true;
        if (tRaw>=1){
          currentShape = params.target;
          const tmpP=A; A=B; B=tmpP; const tmpC=colA; colA=colB; colB=tmpC;
          phase="idle";
          overlay.textContent = `N=${N} | at ${currentShape} · next → ${params.target}`;
        }
      }
      else if (phase==="dissolving"){
        const tt=tRaw; ptsMat.opacity=1-tt;
        for (let i=0;i<N;i++){
          C[3*i]=A[3*i]+dissolveVel[3*i]*tt;
          C[3*i+1]=A[3*i+1]+dissolveVel[3*i+1]*tt;
          C[3*i+2]=A[3*i+2]+dissolveVel[3*i+2]*tt;
        }
        geom.getAttribute('position').needsUpdate=true;

        if (tt>=1){
          for (let i=0;i<N;i++){
            C[3*i]=(Math.random()*2-1)*3.5;
            C[3*i+1]=(Math.random()*2-1)*3.5;
            C[3*i+2]=(Math.random()*2-1)*3.5;
          }
          ptsMat.opacity=0; phase="rebuilding"; animMs=params.dissolveMs; t0=performance.now();
        }
      }
      else if (phase==="rebuilding"){
        const tt=easeInOutCubic((now-t0)/animMs); ptsMat.opacity=tt;
        for (let i=0;i<N;i++){
          const j=perm[i];
          const bx=B[3*j], by=B[3*j+1], bz=B[3*j+2]; const [jx,jy,jz]=jitterVec(i);
          C[3*i]=C[3*i]*(1-tt)+(bx+jx)*tt;
          C[3*i+1]=C[3*i+1]*(1-tt)+(by+jy)*tt;
          C[3*i+2]=C[3*i+2]*(1-tt)+(bz+jz)*tt;
        }
        applyColor(tt); geom.getAttribute('position').needsUpdate=true; geom.getAttribute('color').needsUpdate=true;
        if ((now-t0)>=animMs){
          currentShape=params.target; const tmpP=A; A=B; B=tmpP; const tmpC=colA; colA=colB; colB=tmpC; phase="idle"; ptsMat.opacity=1;
        }
      }
    }

    // ---------- Input (desktop) ----------
    window.addEventListener("keydown",(e)=>{
      const k=e.key.toLowerCase();
      if (k===" "){ triggerTransition(); }
      else if (k==="c"){ params.target = (params.target==="sphere"?"cube":"sphere"); triggerTransition(); }
      else if (k==="r"){ permutePairing(); triggerTransition(); }
      else if (k==="p"){ paused = !paused; }
      else if (k==="f"){ toggleFullscreen(); }
      else if (k==="x"){ recenterAR(); }
      else if (k==="1"){ params.mode = MODES["1 · Morph (ease)"]; startMorph(); }
      else if (k==="2"){ params.mode = MODES["2 · Swirl Morph"]; startMorph(); }
      else if (k==="3"){ params.mode = MODES["3 · Bezier Flow"]; startMorph(); }
      else if (k==="4"){ params.mode = MODES["4 · Dissolve/Rebuild"]; startDissolveRebuild(); }
      else if (k==="5"){ params.mode = MODES["5 · Staggered Build"]; startMorph(); }
      overlay.textContent = `N=${N} | ${currentShape} → ${params.target} | mode=${params.mode}`;
    });

    async function toggleFullscreen(){
      try{
        if (!document.fullscreenElement) await document.body.requestFullscreen({navigationUI:"hide"}).catch(()=>document.body.requestFullscreen());
        else await document.exitFullscreen();
      }catch(e){}
    }

    // ---------- WebXR buttons: add only supported one ----------
    (async ()=>{
      if (!('xr' in navigator)) return;
      try{
        if (await navigator.xr.isSessionSupported('immersive-ar')){
          document.body.appendChild( ARButton.createButton(renderer, {
            requiredFeatures: ['local-floor']
          }) );
        } else if (await navigator.xr.isSessionSupported('immersive-vr')){
          document.body.appendChild( XRButton.createButton(renderer, {
            optionalFeatures: ['local-floor','bounded-floor','hand-tracking','layers']
          }) );
        }
      } catch(e){ /* ignore */ }
      })();

    // Controllers & models
      const controllerModelFactory = new XRControllerModelFactory();
      const controller0 = renderer.xr.getController(0);
      const controller1 = renderer.xr.getController(1);
      scene.add(controller0, controller1);

      const grip0 = renderer.xr.getControllerGrip(0);
      const grip1 = renderer.xr.getControllerGrip(1);
      grip0.add(controllerModelFactory.createControllerModel(grip0));
      grip1.add(controllerModelFactory.createControllerModel(grip1));
      scene.add(grip0, grip1);

    // Trigger (select) → next shape  (refresh GUI correctly)
      const nextShape = ()=>{
        const idx = SHAPES.indexOf(params.target);
        params.target = SHAPES[(idx + 1) % SHAPES.length];
        gui.controllersRecursive().forEach(c => c.updateDisplay());
        triggerTransition();
      };
      controller0.addEventListener('selectstart', nextShape);
      controller1.addEventListener('selectstart', nextShape);

    // Optional: map A/B (or primary/secondary) to recenter during AR
      const recenterOnEvent = () => recenterAR();
      controller0.addEventListener('squeezestart', recenterOnEvent);
      controller1.addEventListener('squeezestart', recenterOnEvent);

    // ---------- XR session hooks ----------
      renderer.xr.addEventListener('sessionstart', ()=>{
        controls.enabled = false;
        const s = renderer.xr.getSession();
        const blend = s?.environmentBlendMode || 'opaque';
        const isAR = (blend !== 'opaque');

        if (isAR){
          scene.background = null;
          renderer.setClearAlpha(0);

        // Floor & grid should align to real floor in 'local-floor' space
          grid.visible = true;
          floor.visible = true;

        // Defer placement to first XR frame to use current head pose
          needsARPlace = true;
        } else {
          scene.background = new THREE.Color(0x000000);
          renderer.setClearAlpha(1);
          cloudGroup.position.set(0, 0, -1.6);
          cloudGroup.scale.setScalar(1);
          ptsMat.sizeAttenuation = true;
          ptsMat.size = params.pointSize;
          ptsMat.blending = params.additive ? THREE.AdditiveBlending : THREE.NormalBlending;
          ptsMat.needsUpdate = true;

          grid.visible = true;
          floor.visible = true;
        }
      });

      renderer.xr.addEventListener('sessionend', ()=>{
        controls.enabled = true;
        scene.background = new THREE.Color(0x000000);
        renderer.setClearAlpha(1);
        cloudGroup.position.set(0,0,0);
        cloudGroup.scale.setScalar(1);

      // restore desktop material settings
        ptsMat.sizeAttenuation = true;
        ptsMat.size = params.pointSize;
        ptsMat.blending = params.additive ? THREE.AdditiveBlending : THREE.NormalBlending;
        ptsMat.needsUpdate = true;

        lastUserInteractT = performance.now();
      });

    // ---------- Boot ----------
      rebuildAll();

      window.addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
        if (paused) renderer.render(scene,camera);
      });
    </script>
  </body>
  </html>
