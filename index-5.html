<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Live Depth Point Cloud + Rain Collisions</title>
  <link rel="icon" href="data:,">
  <style>
    html,body { margin:0; height:100%; overflow:hidden; background:#000; }
    #overlay { position:fixed; top:12px; left:12px; color:#0f0; font:12px/1.4 monospace; background:rgba(0,0,0,.4); padding:8px 10px; border-radius:8px; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.180.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.180.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="overlay">connecting…</div>
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    const overlay = document.getElementById("overlay");

    // --- Scene ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 100);
    camera.position.set(0, 0, 2);

    // preserveDrawingBuffer for PNG capture
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- Live cloud (with tweening) ---
    const cloudMaterial = new THREE.PointsMaterial({ size: 0.01, vertexColors: true, sizeAttenuation: true });
    const cloudGeom = new THREE.BufferGeometry();
    const cloudPoints = new THREE.Points(cloudGeom, cloudMaterial);
    scene.add(cloudPoints);

    let lastPos=null, nextPos=null, curPos=null, curCol=null;
    let tweenT = 1, targetTweenMs = 120, lastArrival = performance.now();

    function ensureCloudBuffers(N){
      const needAlloc = !cloudGeom.getAttribute('position') || cloudGeom.getAttribute('position').count !== N;
      if (needAlloc){
        curPos  = new Float32Array(N*3);
        curCol  = new Float32Array(N*3);
        lastPos = new Float32Array(N*3);
        nextPos = new Float32Array(N*3);
        cloudGeom.setAttribute('position', new THREE.BufferAttribute(curPos, 3));
        cloudGeom.setAttribute('color',    new THREE.BufferAttribute(curCol, 3));
      } else {
        curPos = cloudGeom.getAttribute('position').array;
        curCol = cloudGeom.getAttribute('color').array;
        if (!lastPos || lastPos.length !== curPos.length) lastPos = new Float32Array(curPos.length);
        if (!nextPos || nextPos.length !== curPos.length) nextPos = new Float32Array(curPos.length);
      }
    }

    function parseFrame(buffer){
      const dv = new DataView(buffer);
      const headerLen = dv.getUint32(0, true);
      let offset = 4;
      if (headerLen === 0) return { hello:true };

      const headerStr = new TextDecoder().decode(new Uint8Array(buffer, offset, headerLen));
      offset += headerLen;

      const mis = offset & 3; if (mis) offset += (4 - mis);

      const header = JSON.parse(headerStr);
      const N = header.w * header.h;

      const depth = new Float32Array(buffer, offset, N);
      offset += N * 4;

      const rgb = new Uint8Array(buffer, offset, N * 3);
      return { header, depth, rgb };
    }

    function unprojectInto(targetArray, colorArray, header, depth, rgb){
      const { w,h, fx,fy, cx,cy } = header;
      let k=0, c=0;
      for (let v=0; v<h; v++){
        for (let u=0; u<w; u++){
          const i = v*w + u;
          const Z = depth[i];
          const X = (u - cx) / fx * Z;
          const Y = (v - cy) / fy * Z;

          targetArray[k++] =  X;
          targetArray[k++] = -Y;
          targetArray[k++] = -Z;

          colorArray[i*3    ] = rgb[c++] / 255;
          colorArray[i*3 + 1] = rgb[c++] / 255;
          colorArray[i*3 + 2] = rgb[c++] / 255;
        }
      }
    }

    // --- Collision grid built from nextPos ---
    const CELL = 0.03;
    const SAMPLE_STRIDE = 3;
    const COLLISION_RADIUS = 0.045;
    let occGrid = new Map();
    let cloudBounds = { center:new THREE.Vector3(0,0,-1.2), radius:0.8 };
    function keyFrom(ix,iy,iz){ return ix + "," + iy + "," + iz; }

    function rebuildGridFromCloud(){
      occGrid.clear();
      if (!nextPos) return;
      const L = nextPos.length / 3;

      let minx=Infinity,miny=Infinity,minz=Infinity, maxx=-Infinity,maxy=-Infinity,maxz=-Infinity;

      for (let i=0; i<L; i += SAMPLE_STRIDE){
        const x = nextPos[3*i+0], y = nextPos[3*i+1], z = nextPos[3*i+2];
        if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) continue;
        const ix = Math.floor(x/CELL), iy = Math.floor(y/CELL), iz = Math.floor(z/CELL);
        const k = keyFrom(ix,iy,iz);
        if (!occGrid.has(k)) occGrid.set(k, {x,y,z});

        if (x<minx) minx=x; if (y<miny) miny=y; if (z<minz) minz=z;
        if (x>maxx) maxx=x; if (y>maxy) maxy=y; if (z>maxz) maxz=z;
      }

      if (isFinite(minx)){
        const cx=(minx+maxx)/2, cy=(miny+maxy)/2, cz=(minz+maxz)/2;
        const rx=(maxx-minx)/2, ry=(maxy-miny)/2, rz=(maxz-minz)/2;
        cloudBounds.center.set(cx,cy,cz);
        cloudBounds.radius = Math.max(rx,ry,rz) || 0.8;
      }
    }

    const NEIGH = [];
    for (let dz=-1; dz<=1; dz++) for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) NEIGH.push([dx,dy,dz]);

      function collidesWithCloud(x,y,z){
        const ix = Math.floor(x/CELL), iy = Math.floor(y/CELL), iz = Math.floor(z/CELL);
        const r2 = COLLISION_RADIUS*COLLISION_RADIUS;
        for (const [dx,dy,dz] of NEIGH){
          const p = occGrid.get(keyFrom(ix+dx, iy+dy, iz+dz));
          if (!p) continue;
          const dxp = x - p.x, dyp = y - p.y, dzp = z - p.z;
          if (dxp*dxp + dyp*dyp + dzp*dzp <= r2) return true;
        }
        return false;
      }

    // --- Rain system with multiple collision behaviours ---
      const RAIN_COUNT = 1200;
      const GRAVITY = 1.6;
      const HIT_FLASH_MS = 180;
      const STICK_MS = 700;
      const RAIN_SPREAD = 1.2;

    // behaviours
      const BEHAVIOUR = {
      STICK: 1,         // 1) stay (current)
      FLY_UP: 2,        // 2) fly back to the top
      RADIAL: 3,        // 3) bounce radially outward
      RANDOM: 4         // 4) random bounce
    };
    let behaviour = BEHAVIOUR.STICK;

    const rainGeom = new THREE.BufferGeometry();
    const rainPos = new Float32Array(RAIN_COUNT*3);
    const rainCol = new Float32Array(RAIN_COUNT*3);
    const rainVX = new Float32Array(RAIN_COUNT);
    const rainVY = new Float32Array(RAIN_COUNT);
    const rainVZ = new Float32Array(RAIN_COUNT);
    const rainFlash = new Float32Array(RAIN_COUNT);
    const rainStick = new Float32Array(RAIN_COUNT);
    const rainBounce = new Float32Array(RAIN_COUNT); // ms to keep bounce mode gravity-suppressed

    function respawnDrop(i){
      const R = cloudBounds.radius || 0.8;
      const c = cloudBounds.center;
      const spread = R*RAIN_SPREAD;
      rainPos[3*i+0] = c.x + (Math.random()*2-1)*spread;
      rainPos[3*i+2] = c.z + (Math.random()*2-1)*spread;
      rainPos[3*i+1] = c.y + (R + 0.6 + Math.random()*0.4);

      rainVX[i] = 0;
      rainVY[i] = -(0.6 + Math.random()*0.4); // small initial downward push (will add gravity)
      rainVZ[i] = 0;

      rainFlash[i] = 0;
      rainStick[i] = 0;
      rainBounce[i] = 0;

      // base blue
      rainCol[3*i+0] = 0.5; rainCol[3*i+1] = 0.7; rainCol[3*i+2] = 1.0;
    }

    function initRain(){
      for (let i=0;i<RAIN_COUNT;i++) respawnDrop(i);
        rainGeom.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));
      rainGeom.setAttribute('color',    new THREE.BufferAttribute(rainCol, 3));
      const rainMat = new THREE.PointsMaterial({ size: 0.012, vertexColors: true, sizeAttenuation: true });
      const rainPoints = new THREE.Points(rainGeom, rainMat);
      scene.add(rainPoints);
    }
    initRain();

    function impulseOnHit(i){
      // flash
      rainFlash[i] = HIT_FLASH_MS;

      const x = rainPos[3*i+0], y = rainPos[3*i+1], z = rainPos[3*i+2];
      const c = cloudBounds.center;

      if (behaviour === BEHAVIOUR.STICK){
        rainStick[i] = STICK_MS;
        rainVX[i] = rainVY[i] = rainVZ[i] = 0;
      }
      else if (behaviour === BEHAVIOUR.FLY_UP){
        // shoot upward; give slight outward jitter for parallax
        rainVY[i] = 3.2 + Math.random()*0.8;
        rainVX[i] = (Math.random()*2-1) * 0.3;
        rainVZ[i] = (Math.random()*2-1) * 0.3;
        rainBounce[i] = 450; // ms with reduced gravity
      }
      else if (behaviour === BEHAVIOUR.RADIAL){
        // push away from cloud center ("sun rays")
        let dx = x - c.x, dy = y - c.y, dz = z - c.z;
        const len = Math.hypot(dx,dy,dz) || 1;
        dx/=len; dy/=len; dz/=len;
        const speed = 2.4 + Math.random()*0.8;
        rainVX[i] = dx * speed;
        rainVY[i] = dy * speed;
        rainVZ[i] = dz * speed;
        rainBounce[i] = 600;
      }
      else if (behaviour === BEHAVIOUR.RANDOM){
        // random unit direction
        let dx = Math.random()*2-1, dy = Math.random()*2-1, dz = Math.random()*2-1;
        const len = Math.hypot(dx,dy,dz) || 1;
        dx/=len; dy/=len; dz/=len;
        const speed = 2.2 + Math.random()*1.2;
        rainVX[i] = dx * speed;
        rainVY[i] = dy * speed;
        rainVZ[i] = dz * speed;
        rainBounce[i] = 500;
      }
    }

    function stepRain(dt){
      const R = (cloudBounds.radius||0.8) + 0.5;
      const floorY = cloudBounds.center.y - R;

      for (let i=0;i<RAIN_COUNT;i++){
        const base = 3*i;

        // Update “stuck”
        if (rainStick[i] > 0){
          rainStick[i] -= dt*1000;
          // leave it in place, maybe keep faint flash
          rainFlash[i] = Math.max(rainFlash[i], 40);
        } else {
          // Gravity (reduced while bouncing)
          let g = GRAVITY;
          if (rainBounce[i] > 0) {
            g *= 0.25;                  // softer gravity during bounce
            rainBounce[i] -= dt*1000;
          }
          // Integrate velocities
          rainVY[i] -= g * dt;

          // Integrate positions
          rainPos[base+0] += rainVX[i] * dt;
          rainPos[base+1] += rainVY[i] * dt;
          rainPos[base+2] += rainVZ[i] * dt;

          // Collision test
          const x = rainPos[base+0], y = rainPos[base+1], z = rainPos[base+2];
          if (collidesWithCloud(x,y,z)){
            impulseOnHit(i);
          }
        }

        // Flash colour
        if (rainFlash[i] > 0){
          rainFlash[i] -= dt*1000;
          const t = Math.max(0, Math.min(1, rainFlash[i]/HIT_FLASH_MS));
          rainCol[base+0] = 1.0*t + 0.5*(1-t);
          rainCol[base+1] = 0.1*t + 0.7*(1-t);
          rainCol[base+2] = 0.1*t + 1.0*(1-t);
        } else if (rainStick[i] <= 0){
          rainCol[base+0] = 0.5; rainCol[base+1] = 0.7; rainCol[base+2] = 1.0;
        }

        // Recycle: below floor or way outside bounds
        const c = cloudBounds.center;
        const tooFar = Math.hypot(rainPos[base+0]-c.x, rainPos[base+1]-c.y, rainPos[base+2]-c.z) > (cloudBounds.radius+2.5);
        if ((rainStick[i] <= 0 && rainPos[base+1] < floorY) || tooFar){
          respawnDrop(i);
        }
      }
      rainGeom.getAttribute('position').needsUpdate = true;
      rainGeom.getAttribute('color').needsUpdate    = true;
    }

    // --- Network / tween / grid update ---
    let statusText = "connecting…";

    function onNewNetworkFrame(parsed){
      const { header, depth, rgb } = parsed;
      const N = header.w * header.h;
      ensureCloudBuffers(N);

      lastPos.set(nextPos);
      unprojectInto(nextPos, curCol, header, depth, rgb);
      cloudGeom.getAttribute('color').needsUpdate = true;

      rebuildGridFromCloud();

      const now = performance.now();
      const inter = Math.min(300, Math.max(30, now - lastArrival));
      lastArrival = now;
      targetTweenMs = 0.8*targetTweenMs + 0.2*inter;
      tweenT = 0;

      statusText = `w=${header.w} h=${header.h} | tween≈${Math.round(targetTweenMs)}ms | rain=${RAIN_COUNT} | mode=${behaviour}`;
    }

    // --- Controls: Pause (P), Save PNG (S), Fullscreen (F), Modes (1–4) ---
    let paused = false;

    function togglePause(){
      paused = !paused;
      statusText = (paused ? "[PAUSED] " : "") + statusText;
      if (paused) renderer.render(scene, camera);
    }

    function savePNG(){
      try{
        const url = renderer.domElement.toDataURL("image/png");
        const a = document.createElement("a");
        const ts = new Date();
        const pad = n=>String(n).padStart(2,"0");
        const name = `pointcloud_${ts.getFullYear()}-${pad(ts.getMonth()+1)}-${pad(ts.getDate())}_${pad(ts.getHours())}-${pad(ts.getMinutes())}-${pad(ts.getSeconds())}.png`;
        a.href = url; a.download = name;
        document.body.appendChild(a);
        a.click(); a.remove();
      } catch(e){ console.warn("PNG save failed:", e); }
    }

    async function toggleFullscreen(){
      try{
        if (!document.fullscreenElement) {
          await document.body.requestFullscreen({ navigationUI: "hide" }).catch(()=>document.body.requestFullscreen());
        } else {
          await document.exitFullscreen();
        }
      } catch(e){ console.warn("Fullscreen toggle failed:", e); }
    }

    function setBehaviour(n){
      behaviour = n;
      statusText = `mode=${n} (1=stick, 2=fly-up, 3=radial, 4=random)`;
    }

    window.addEventListener("keydown", (e)=>{
      const k = e.key.toLowerCase();
      if (k === "p") togglePause();
      else if (k === "s") savePNG();
      else if (k === "f") toggleFullscreen();
      else if (k === "1") setBehaviour(BEHAVIOUR.STICK);
      else if (k === "2") setBehaviour(BEHAVIOUR.FLY_UP);
      else if (k === "3") setBehaviour(BEHAVIOUR.RADIAL);
      else if (k === "4") setBehaviour(BEHAVIOUR.RANDOM);
    });

    // --- Render loop ---
    let lastFrameT = performance.now();
    function render(){
      const t = performance.now();
      const dt = (t - lastFrameT) / 1000; lastFrameT = t;

      if (!paused){
        if (tweenT < 1 && curPos && nextPos && lastPos){
          const step = (dt*1000) / Math.max(1, targetTweenMs);
          tweenT = Math.min(1, tweenT + step);
          const L = curPos.length, a = 1 - tweenT, b = tweenT;
          for (let i=0; i<L; i++) curPos[i] = a*lastPos[i] + b*nextPos[i];
            cloudGeom.getAttribute('position').needsUpdate = true;
          cloudGeom.computeBoundingSphere();
        }
        stepRain(dt);
        controls.update();
        renderer.render(scene, camera);
      }
      requestAnimationFrame(render);
    }

    // --- Overlay FPS/status ---
    let lastTs = performance.now(), frames = 0;
    function tickOverlay(){
      const now = performance.now();
      frames++;
      if (now - lastTs >= 1000){
        overlay.textContent =
      `${statusText} | ${frames} fps | [1..4] modes · [P]ause · [S]ave · [F]ullscreen`;
      frames = 0; lastTs = now;
    }
    requestAnimationFrame(tickOverlay);
  }

    // --- WebSocket ---
  const ws = new WebSocket("ws://localhost:8765");
  ws.binaryType = "arraybuffer";
  ws.onopen = ()=>{ statusText = "connected"; };
  ws.onmessage = (ev)=>{
    const parsed = parseFrame(ev.data);
    if (!parsed.hello) onNewNetworkFrame(parsed);
  };
  ws.onclose = ()=>{ statusText = "disconnected"; };

    // start
  tickOverlay();
  render();

    // resize
  window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    if (paused) renderer.render(scene, camera);
  });
</script>
</body>
</html>
